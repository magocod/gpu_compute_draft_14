/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub const HSAKMT_VERSION_MAJOR: u32 = 0;
pub const HSAKMT_VERSION_MINOR: u32 = 99;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INVALID_QUEUEID: i32 = -1;
pub const INVALID_PID: u32 = 4294967295;
pub const INVALID_NODEID: u32 = 4294967295;
pub const HSA_PUBLIC_NAME_SIZE: u32 = 64;
pub const HSA_CPU_SIBLINGS: u32 = 256;
pub const HSA_PROCESSORID_ALL: u32 = 4294967295;
pub const HSA_RUNTIME_ENABLE_CAPS_SUPPORTS_CORE_DUMP_MASK: u32 = 2147483648;
pub const HSA_SMI_EVENT_MSG_SIZE: u32 = 96;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type HSAuint8 = u8;
pub type HSAint8 = i8;
pub type HSAuint16 = u16;
pub type HSAint16 = i16;
pub type HSAuint32 = u32;
pub type HSAint32 = i32;
pub type HSAint64 = i64;
pub type HSAuint64 = u64;
pub type HSA_HANDLE = *mut ::std::os::raw::c_void;
pub type HSA_QUEUEID = HSAuint64;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_SUCCESS: _HSAKMT_STATUS = 0;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_ERROR: _HSAKMT_STATUS = 1;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_DRIVER_MISMATCH: _HSAKMT_STATUS = 2;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_INVALID_PARAMETER: _HSAKMT_STATUS = 3;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_INVALID_HANDLE: _HSAKMT_STATUS = 4;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_INVALID_NODE_UNIT: _HSAKMT_STATUS = 5;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_NO_MEMORY: _HSAKMT_STATUS = 6;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_BUFFER_TOO_SMALL: _HSAKMT_STATUS = 7;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_NOT_IMPLEMENTED: _HSAKMT_STATUS = 10;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_NOT_SUPPORTED: _HSAKMT_STATUS = 11;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_UNAVAILABLE: _HSAKMT_STATUS = 12;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_OUT_OF_RESOURCES: _HSAKMT_STATUS = 13;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_KERNEL_IO_CHANNEL_NOT_OPENED: _HSAKMT_STATUS = 20;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_KERNEL_COMMUNICATION_ERROR: _HSAKMT_STATUS = 21;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_KERNEL_ALREADY_OPENED: _HSAKMT_STATUS = 22;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_HSAMMU_UNAVAILABLE: _HSAKMT_STATUS = 23;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_WAIT_FAILURE: _HSAKMT_STATUS = 30;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_WAIT_TIMEOUT: _HSAKMT_STATUS = 31;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_MEMORY_ALREADY_REGISTERED: _HSAKMT_STATUS = 35;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_MEMORY_NOT_REGISTERED: _HSAKMT_STATUS = 36;
pub const _HSAKMT_STATUS_HSAKMT_STATUS_MEMORY_ALIGNMENT: _HSAKMT_STATUS = 37;
pub type _HSAKMT_STATUS = ::std::os::raw::c_uint;
pub use self::_HSAKMT_STATUS as HSAKMT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaVersionInfo {
    pub KernelInterfaceMajorVersion: HSAuint32,
    pub KernelInterfaceMinorVersion: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaVersionInfo"][::std::mem::size_of::<_HsaVersionInfo>() - 8usize];
    ["Alignment of _HsaVersionInfo"][::std::mem::align_of::<_HsaVersionInfo>() - 4usize];
    ["Offset of field: _HsaVersionInfo::KernelInterfaceMajorVersion"]
        [::std::mem::offset_of!(_HsaVersionInfo, KernelInterfaceMajorVersion) - 0usize];
    ["Offset of field: _HsaVersionInfo::KernelInterfaceMinorVersion"]
        [::std::mem::offset_of!(_HsaVersionInfo, KernelInterfaceMinorVersion) - 4usize];
};
pub type HsaVersionInfo = _HsaVersionInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaSystemProperties {
    pub NumNodes: HSAuint32,
    pub PlatformOem: HSAuint32,
    pub PlatformId: HSAuint32,
    pub PlatformRev: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaSystemProperties"][::std::mem::size_of::<_HsaSystemProperties>() - 16usize];
    ["Alignment of _HsaSystemProperties"][::std::mem::align_of::<_HsaSystemProperties>() - 4usize];
    ["Offset of field: _HsaSystemProperties::NumNodes"]
        [::std::mem::offset_of!(_HsaSystemProperties, NumNodes) - 0usize];
    ["Offset of field: _HsaSystemProperties::PlatformOem"]
        [::std::mem::offset_of!(_HsaSystemProperties, PlatformOem) - 4usize];
    ["Offset of field: _HsaSystemProperties::PlatformId"]
        [::std::mem::offset_of!(_HsaSystemProperties, PlatformId) - 8usize];
    ["Offset of field: _HsaSystemProperties::PlatformRev"]
        [::std::mem::offset_of!(_HsaSystemProperties, PlatformRev) - 12usize];
};
pub type HsaSystemProperties = _HsaSystemProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub union HSA_ENGINE_ID {
    pub Value: HSAuint32,
    pub ui32: HSA_ENGINE_ID__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HSA_ENGINE_ID__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_ENGINE_ID__bindgen_ty_1"]
        [::std::mem::size_of::<HSA_ENGINE_ID__bindgen_ty_1>() - 4usize];
    ["Alignment of HSA_ENGINE_ID__bindgen_ty_1"]
        [::std::mem::align_of::<HSA_ENGINE_ID__bindgen_ty_1>() - 4usize];
};
impl HSA_ENGINE_ID__bindgen_ty_1 {
    #[inline]
    pub fn uCode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_uCode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uCode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uCode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Major(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Major(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Major_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Major_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Minor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Minor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Minor_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Minor_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Stepping(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Stepping(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Stepping_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Stepping_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uCode: ::std::os::raw::c_uint,
        Major: ::std::os::raw::c_uint,
        Minor: ::std::os::raw::c_uint,
        Stepping: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let uCode: u32 = unsafe { ::std::mem::transmute(uCode) };
            uCode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let Major: u32 = unsafe { ::std::mem::transmute(Major) };
            Major as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let Minor: u32 = unsafe { ::std::mem::transmute(Minor) };
            Minor as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Stepping: u32 = unsafe { ::std::mem::transmute(Stepping) };
            Stepping as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_ENGINE_ID"][::std::mem::size_of::<HSA_ENGINE_ID>() - 4usize];
    ["Alignment of HSA_ENGINE_ID"][::std::mem::align_of::<HSA_ENGINE_ID>() - 4usize];
    ["Offset of field: HSA_ENGINE_ID::Value"]
        [::std::mem::offset_of!(HSA_ENGINE_ID, Value) - 0usize];
    ["Offset of field: HSA_ENGINE_ID::ui32"][::std::mem::offset_of!(HSA_ENGINE_ID, ui32) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union HSA_ENGINE_VERSION {
    pub Value: HSAuint32,
    pub __bindgen_anon_1: HSA_ENGINE_VERSION__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HSA_ENGINE_VERSION__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_ENGINE_VERSION__bindgen_ty_1"]
        [::std::mem::size_of::<HSA_ENGINE_VERSION__bindgen_ty_1>() - 4usize];
    ["Alignment of HSA_ENGINE_VERSION__bindgen_ty_1"]
        [::std::mem::align_of::<HSA_ENGINE_VERSION__bindgen_ty_1>() - 4usize];
};
impl HSA_ENGINE_VERSION__bindgen_ty_1 {
    #[inline]
    pub fn uCodeSDMA(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_uCodeSDMA(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uCodeSDMA_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uCodeSDMA_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uCodeRes(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_uCodeRes(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uCodeRes_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                10u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uCodeRes_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                10u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                12u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uCodeSDMA: ::std::os::raw::c_uint,
        uCodeRes: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let uCodeSDMA: u32 = unsafe { ::std::mem::transmute(uCodeSDMA) };
            uCodeSDMA as u64
        });
        __bindgen_bitfield_unit.set(10usize, 10u8, {
            let uCodeRes: u32 = unsafe { ::std::mem::transmute(uCodeRes) };
            uCodeRes as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_ENGINE_VERSION"][::std::mem::size_of::<HSA_ENGINE_VERSION>() - 4usize];
    ["Alignment of HSA_ENGINE_VERSION"][::std::mem::align_of::<HSA_ENGINE_VERSION>() - 4usize];
    ["Offset of field: HSA_ENGINE_VERSION::Value"]
        [::std::mem::offset_of!(HSA_ENGINE_VERSION, Value) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union HSA_CAPABILITY {
    pub Value: HSAuint32,
    pub ui32: HSA_CAPABILITY__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HSA_CAPABILITY__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_CAPABILITY__bindgen_ty_1"]
        [::std::mem::size_of::<HSA_CAPABILITY__bindgen_ty_1>() - 4usize];
    ["Alignment of HSA_CAPABILITY__bindgen_ty_1"]
        [::std::mem::align_of::<HSA_CAPABILITY__bindgen_ty_1>() - 4usize];
};
impl HSA_CAPABILITY__bindgen_ty_1 {
    #[inline]
    pub fn HotPluggable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotPluggable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotPluggable_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotPluggable_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HSAMMUPresent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HSAMMUPresent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HSAMMUPresent_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HSAMMUPresent_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SharedWithGraphics(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SharedWithGraphics(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SharedWithGraphics_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SharedWithGraphics_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn QueueSizePowerOfTwo(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QueueSizePowerOfTwo(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn QueueSizePowerOfTwo_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_QueueSizePowerOfTwo_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn QueueSize32bit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QueueSize32bit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn QueueSize32bit_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_QueueSize32bit_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn QueueIdleEvent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QueueIdleEvent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn QueueIdleEvent_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_QueueIdleEvent_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn VALimit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VALimit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn VALimit_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_VALimit_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WatchPointsSupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WatchPointsSupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WatchPointsSupported_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WatchPointsSupported_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WatchPointsTotalBits(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_WatchPointsTotalBits(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WatchPointsTotalBits_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WatchPointsTotalBits_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DoorbellType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DoorbellType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DoorbellType_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DoorbellType_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AQLQueueDoubleMap(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AQLQueueDoubleMap(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AQLQueueDoubleMap_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AQLQueueDoubleMap_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DebugTrapSupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DebugTrapSupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DebugTrapSupported_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DebugTrapSupported_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WaveLaunchTrapOverrideSupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WaveLaunchTrapOverrideSupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WaveLaunchTrapOverrideSupported_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WaveLaunchTrapOverrideSupported_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uint,
    ) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WaveLaunchModeSupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WaveLaunchModeSupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WaveLaunchModeSupported_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_WaveLaunchModeSupported_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseMemoryOperationsSupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreciseMemoryOperationsSupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseMemoryOperationsSupported_raw(
        this: *const Self,
    ) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseMemoryOperationsSupported_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uint,
    ) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DEPRECATED_SRAM_EDCSupport(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DEPRECATED_SRAM_EDCSupport(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DEPRECATED_SRAM_EDCSupport_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DEPRECATED_SRAM_EDCSupport_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Mem_EDCSupport(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Mem_EDCSupport(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Mem_EDCSupport_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Mem_EDCSupport_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn RASEventNotify(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RASEventNotify(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn RASEventNotify_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_RASEventNotify_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ASICRevision(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ASICRevision(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ASICRevision_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ASICRevision_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SRAM_EDCSupport(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SRAM_EDCSupport(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SRAM_EDCSupport_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                26usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SRAM_EDCSupport_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                26usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn SVMAPISupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SVMAPISupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn SVMAPISupported_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_SVMAPISupported_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CoherentHostAccess(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoherentHostAccess(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CoherentHostAccess_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CoherentHostAccess_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DebugSupportedFirmware(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DebugSupportedFirmware(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DebugSupportedFirmware_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_DebugSupportedFirmware_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PreciseALUOperationsSupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreciseALUOperationsSupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PreciseALUOperationsSupported_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PreciseALUOperationsSupported_raw(
        this: *mut Self,
        val: ::std::os::raw::c_uint,
    ) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PerQueueResetSupported(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PerQueueResetSupported(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PerQueueResetSupported_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PerQueueResetSupported_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HotPluggable: ::std::os::raw::c_uint,
        HSAMMUPresent: ::std::os::raw::c_uint,
        SharedWithGraphics: ::std::os::raw::c_uint,
        QueueSizePowerOfTwo: ::std::os::raw::c_uint,
        QueueSize32bit: ::std::os::raw::c_uint,
        QueueIdleEvent: ::std::os::raw::c_uint,
        VALimit: ::std::os::raw::c_uint,
        WatchPointsSupported: ::std::os::raw::c_uint,
        WatchPointsTotalBits: ::std::os::raw::c_uint,
        DoorbellType: ::std::os::raw::c_uint,
        AQLQueueDoubleMap: ::std::os::raw::c_uint,
        DebugTrapSupported: ::std::os::raw::c_uint,
        WaveLaunchTrapOverrideSupported: ::std::os::raw::c_uint,
        WaveLaunchModeSupported: ::std::os::raw::c_uint,
        PreciseMemoryOperationsSupported: ::std::os::raw::c_uint,
        DEPRECATED_SRAM_EDCSupport: ::std::os::raw::c_uint,
        Mem_EDCSupport: ::std::os::raw::c_uint,
        RASEventNotify: ::std::os::raw::c_uint,
        ASICRevision: ::std::os::raw::c_uint,
        SRAM_EDCSupport: ::std::os::raw::c_uint,
        SVMAPISupported: ::std::os::raw::c_uint,
        CoherentHostAccess: ::std::os::raw::c_uint,
        DebugSupportedFirmware: ::std::os::raw::c_uint,
        PreciseALUOperationsSupported: ::std::os::raw::c_uint,
        PerQueueResetSupported: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HotPluggable: u32 = unsafe { ::std::mem::transmute(HotPluggable) };
            HotPluggable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HSAMMUPresent: u32 = unsafe { ::std::mem::transmute(HSAMMUPresent) };
            HSAMMUPresent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SharedWithGraphics: u32 = unsafe { ::std::mem::transmute(SharedWithGraphics) };
            SharedWithGraphics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let QueueSizePowerOfTwo: u32 = unsafe { ::std::mem::transmute(QueueSizePowerOfTwo) };
            QueueSizePowerOfTwo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let QueueSize32bit: u32 = unsafe { ::std::mem::transmute(QueueSize32bit) };
            QueueSize32bit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let QueueIdleEvent: u32 = unsafe { ::std::mem::transmute(QueueIdleEvent) };
            QueueIdleEvent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let VALimit: u32 = unsafe { ::std::mem::transmute(VALimit) };
            VALimit as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let WatchPointsSupported: u32 = unsafe { ::std::mem::transmute(WatchPointsSupported) };
            WatchPointsSupported as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let WatchPointsTotalBits: u32 = unsafe { ::std::mem::transmute(WatchPointsTotalBits) };
            WatchPointsTotalBits as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let DoorbellType: u32 = unsafe { ::std::mem::transmute(DoorbellType) };
            DoorbellType as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let AQLQueueDoubleMap: u32 = unsafe { ::std::mem::transmute(AQLQueueDoubleMap) };
            AQLQueueDoubleMap as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DebugTrapSupported: u32 = unsafe { ::std::mem::transmute(DebugTrapSupported) };
            DebugTrapSupported as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WaveLaunchTrapOverrideSupported: u32 =
                unsafe { ::std::mem::transmute(WaveLaunchTrapOverrideSupported) };
            WaveLaunchTrapOverrideSupported as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let WaveLaunchModeSupported: u32 =
                unsafe { ::std::mem::transmute(WaveLaunchModeSupported) };
            WaveLaunchModeSupported as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PreciseMemoryOperationsSupported: u32 =
                unsafe { ::std::mem::transmute(PreciseMemoryOperationsSupported) };
            PreciseMemoryOperationsSupported as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let DEPRECATED_SRAM_EDCSupport: u32 =
                unsafe { ::std::mem::transmute(DEPRECATED_SRAM_EDCSupport) };
            DEPRECATED_SRAM_EDCSupport as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Mem_EDCSupport: u32 = unsafe { ::std::mem::transmute(Mem_EDCSupport) };
            Mem_EDCSupport as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let RASEventNotify: u32 = unsafe { ::std::mem::transmute(RASEventNotify) };
            RASEventNotify as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let ASICRevision: u32 = unsafe { ::std::mem::transmute(ASICRevision) };
            ASICRevision as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let SRAM_EDCSupport: u32 = unsafe { ::std::mem::transmute(SRAM_EDCSupport) };
            SRAM_EDCSupport as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SVMAPISupported: u32 = unsafe { ::std::mem::transmute(SVMAPISupported) };
            SVMAPISupported as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let CoherentHostAccess: u32 = unsafe { ::std::mem::transmute(CoherentHostAccess) };
            CoherentHostAccess as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let DebugSupportedFirmware: u32 =
                unsafe { ::std::mem::transmute(DebugSupportedFirmware) };
            DebugSupportedFirmware as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let PreciseALUOperationsSupported: u32 =
                unsafe { ::std::mem::transmute(PreciseALUOperationsSupported) };
            PreciseALUOperationsSupported as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let PerQueueResetSupported: u32 =
                unsafe { ::std::mem::transmute(PerQueueResetSupported) };
            PerQueueResetSupported as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_CAPABILITY"][::std::mem::size_of::<HSA_CAPABILITY>() - 4usize];
    ["Alignment of HSA_CAPABILITY"][::std::mem::align_of::<HSA_CAPABILITY>() - 4usize];
    ["Offset of field: HSA_CAPABILITY::Value"]
        [::std::mem::offset_of!(HSA_CAPABILITY, Value) - 0usize];
    ["Offset of field: HSA_CAPABILITY::ui32"]
        [::std::mem::offset_of!(HSA_CAPABILITY, ui32) - 0usize];
};

// FIXME bindings c repr
// #[repr(C, packed(4))]
#[repr(C)]
#[derive(Copy, Clone)]
pub union HSA_DEBUG_PROPERTIES {
    pub Value: HSAuint64,
    pub __bindgen_anon_1: HSA_DEBUG_PROPERTIES__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HSA_DEBUG_PROPERTIES__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_DEBUG_PROPERTIES__bindgen_ty_1"]
        [::std::mem::size_of::<HSA_DEBUG_PROPERTIES__bindgen_ty_1>() - 8usize];
    ["Alignment of HSA_DEBUG_PROPERTIES__bindgen_ty_1"]
        [::std::mem::align_of::<HSA_DEBUG_PROPERTIES__bindgen_ty_1>() - 4usize];
};
impl HSA_DEBUG_PROPERTIES__bindgen_ty_1 {
    #[inline]
    pub fn WatchAddrMaskLoBit(&self) -> HSAuint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_WatchAddrMaskLoBit(&mut self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WatchAddrMaskLoBit_raw(this: *const Self) -> HSAuint64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_WatchAddrMaskLoBit_raw(this: *mut Self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn WatchAddrMaskHiBit(&self) -> HSAuint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_WatchAddrMaskHiBit(&mut self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn WatchAddrMaskHiBit_raw(this: *const Self) -> HSAuint64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                6u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_WatchAddrMaskHiBit_raw(this: *mut Self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn DispatchInfoAlwaysValid(&self) -> HSAuint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DispatchInfoAlwaysValid(&mut self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn DispatchInfoAlwaysValid_raw(this: *const Self) -> HSAuint64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_DispatchInfoAlwaysValid_raw(this: *mut Self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AddressWatchpointShareKind(&self) -> HSAuint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AddressWatchpointShareKind(&mut self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AddressWatchpointShareKind_raw(this: *const Self) -> HSAuint64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_AddressWatchpointShareKind_raw(this: *mut Self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> HSAuint64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> HSAuint64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                52u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: HSAuint64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                52u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WatchAddrMaskLoBit: HSAuint64,
        WatchAddrMaskHiBit: HSAuint64,
        DispatchInfoAlwaysValid: HSAuint64,
        AddressWatchpointShareKind: HSAuint64,
        Reserved: HSAuint64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let WatchAddrMaskLoBit: u64 = unsafe { ::std::mem::transmute(WatchAddrMaskLoBit) };
            WatchAddrMaskLoBit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let WatchAddrMaskHiBit: u64 = unsafe { ::std::mem::transmute(WatchAddrMaskHiBit) };
            WatchAddrMaskHiBit as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DispatchInfoAlwaysValid: u64 =
                unsafe { ::std::mem::transmute(DispatchInfoAlwaysValid) };
            DispatchInfoAlwaysValid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AddressWatchpointShareKind: u64 =
                unsafe { ::std::mem::transmute(AddressWatchpointShareKind) };
            AddressWatchpointShareKind as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_DEBUG_PROPERTIES"][::std::mem::size_of::<HSA_DEBUG_PROPERTIES>() - 8usize];
    // FIXME bindings generation
    // ["Alignment of HSA_DEBUG_PROPERTIES"][::std::mem::align_of::<HSA_DEBUG_PROPERTIES>() - 4usize];
    ["Offset of field: HSA_DEBUG_PROPERTIES::Value"]
        [::std::mem::offset_of!(HSA_DEBUG_PROPERTIES, Value) - 0usize];
};
// FIXME bindings c repr
// #[repr(C, packed(4))]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaNodeProperties {
    pub NumCPUCores: HSAuint32,
    pub NumFComputeCores: HSAuint32,
    pub NumMemoryBanks: HSAuint32,
    pub NumCaches: HSAuint32,
    pub NumIOLinks: HSAuint32,
    pub CComputeIdLo: HSAuint32,
    pub FComputeIdLo: HSAuint32,
    pub Capability: HSA_CAPABILITY,
    pub MaxWavesPerSIMD: HSAuint32,
    pub LDSSizeInKB: HSAuint32,
    pub GDSSizeInKB: HSAuint32,
    pub WaveFrontSize: HSAuint32,
    pub NumShaderBanks: HSAuint32,
    pub NumArrays: HSAuint32,
    pub NumCUPerArray: HSAuint32,
    pub NumSIMDPerCU: HSAuint32,
    pub MaxSlotsScratchCU: HSAuint32,
    pub EngineId: HSA_ENGINE_ID,
    pub OverrideEngineId: HSA_ENGINE_ID,
    pub VendorId: HSAuint16,
    pub DeviceId: HSAuint16,
    pub LocationId: HSAuint32,
    pub LocalMemSize: HSAuint64,
    pub MaxEngineClockMhzFCompute: HSAuint32,
    pub MaxEngineClockMhzCCompute: HSAuint32,
    pub DrmRenderMinor: HSAint32,
    pub MarketingName: [HSAuint16; 64usize],
    pub AMDName: [HSAuint8; 64usize],
    pub uCodeEngineVersions: HSA_ENGINE_VERSION,
    pub DebugProperties: HSA_DEBUG_PROPERTIES,
    pub HiveID: HSAuint64,
    pub NumSdmaEngines: HSAuint32,
    pub NumSdmaXgmiEngines: HSAuint32,
    pub NumSdmaQueuesPerEngine: HSAuint8,
    pub NumCpQueues: HSAuint8,
    pub NumGws: HSAuint8,
    pub Integrated: HSAuint8,
    pub Domain: HSAuint32,
    pub UniqueID: HSAuint64,
    pub VGPRSizePerCU: HSAuint32,
    pub SGPRSizePerCU: HSAuint32,
    pub NumXcc: HSAuint32,
    pub KFDGpuID: HSAuint32,
    pub FamilyID: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    // FIXME bindings generation
    // ["Size of _HsaNodeProperties"][::std::mem::size_of::<_HsaNodeProperties>() - 360usize];
    // ["Alignment of _HsaNodeProperties"][::std::mem::align_of::<_HsaNodeProperties>() - 4usize];
    ["Offset of field: _HsaNodeProperties::NumCPUCores"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumCPUCores) - 0usize];
    ["Offset of field: _HsaNodeProperties::NumFComputeCores"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumFComputeCores) - 4usize];
    ["Offset of field: _HsaNodeProperties::NumMemoryBanks"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumMemoryBanks) - 8usize];
    ["Offset of field: _HsaNodeProperties::NumCaches"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumCaches) - 12usize];
    ["Offset of field: _HsaNodeProperties::NumIOLinks"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumIOLinks) - 16usize];
    ["Offset of field: _HsaNodeProperties::CComputeIdLo"]
        [::std::mem::offset_of!(_HsaNodeProperties, CComputeIdLo) - 20usize];
    ["Offset of field: _HsaNodeProperties::FComputeIdLo"]
        [::std::mem::offset_of!(_HsaNodeProperties, FComputeIdLo) - 24usize];
    ["Offset of field: _HsaNodeProperties::Capability"]
        [::std::mem::offset_of!(_HsaNodeProperties, Capability) - 28usize];
    ["Offset of field: _HsaNodeProperties::MaxWavesPerSIMD"]
        [::std::mem::offset_of!(_HsaNodeProperties, MaxWavesPerSIMD) - 32usize];
    ["Offset of field: _HsaNodeProperties::LDSSizeInKB"]
        [::std::mem::offset_of!(_HsaNodeProperties, LDSSizeInKB) - 36usize];
    ["Offset of field: _HsaNodeProperties::GDSSizeInKB"]
        [::std::mem::offset_of!(_HsaNodeProperties, GDSSizeInKB) - 40usize];
    ["Offset of field: _HsaNodeProperties::WaveFrontSize"]
        [::std::mem::offset_of!(_HsaNodeProperties, WaveFrontSize) - 44usize];
    ["Offset of field: _HsaNodeProperties::NumShaderBanks"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumShaderBanks) - 48usize];
    ["Offset of field: _HsaNodeProperties::NumArrays"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumArrays) - 52usize];
    ["Offset of field: _HsaNodeProperties::NumCUPerArray"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumCUPerArray) - 56usize];
    ["Offset of field: _HsaNodeProperties::NumSIMDPerCU"]
        [::std::mem::offset_of!(_HsaNodeProperties, NumSIMDPerCU) - 60usize];
    ["Offset of field: _HsaNodeProperties::MaxSlotsScratchCU"]
        [::std::mem::offset_of!(_HsaNodeProperties, MaxSlotsScratchCU) - 64usize];
    ["Offset of field: _HsaNodeProperties::EngineId"]
        [::std::mem::offset_of!(_HsaNodeProperties, EngineId) - 68usize];
    ["Offset of field: _HsaNodeProperties::OverrideEngineId"]
        [::std::mem::offset_of!(_HsaNodeProperties, OverrideEngineId) - 72usize];
    ["Offset of field: _HsaNodeProperties::VendorId"]
        [::std::mem::offset_of!(_HsaNodeProperties, VendorId) - 76usize];
    ["Offset of field: _HsaNodeProperties::DeviceId"]
        [::std::mem::offset_of!(_HsaNodeProperties, DeviceId) - 78usize];
    ["Offset of field: _HsaNodeProperties::LocationId"]
        [::std::mem::offset_of!(_HsaNodeProperties, LocationId) - 80usize];
    // ["Offset of field: _HsaNodeProperties::LocalMemSize"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, LocalMemSize) - 84usize];
    // ["Offset of field: _HsaNodeProperties::MaxEngineClockMhzFCompute"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, MaxEngineClockMhzFCompute) - 92usize];
    // ["Offset of field: _HsaNodeProperties::MaxEngineClockMhzCCompute"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, MaxEngineClockMhzCCompute) - 96usize];
    // ["Offset of field: _HsaNodeProperties::DrmRenderMinor"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, DrmRenderMinor) - 100usize];
    // ["Offset of field: _HsaNodeProperties::MarketingName"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, MarketingName) - 104usize];
    // ["Offset of field: _HsaNodeProperties::AMDName"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, AMDName) - 232usize];
    // ["Offset of field: _HsaNodeProperties::uCodeEngineVersions"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, uCodeEngineVersions) - 296usize];
    // ["Offset of field: _HsaNodeProperties::DebugProperties"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, DebugProperties) - 300usize];
    // ["Offset of field: _HsaNodeProperties::HiveID"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, HiveID) - 308usize];
    // ["Offset of field: _HsaNodeProperties::NumSdmaEngines"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, NumSdmaEngines) - 316usize];
    // ["Offset of field: _HsaNodeProperties::NumSdmaXgmiEngines"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, NumSdmaXgmiEngines) - 320usize];
    // ["Offset of field: _HsaNodeProperties::NumSdmaQueuesPerEngine"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, NumSdmaQueuesPerEngine) - 324usize];
    // ["Offset of field: _HsaNodeProperties::NumCpQueues"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, NumCpQueues) - 325usize];
    // ["Offset of field: _HsaNodeProperties::NumGws"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, NumGws) - 326usize];
    // ["Offset of field: _HsaNodeProperties::Integrated"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, Integrated) - 327usize];
    // ["Offset of field: _HsaNodeProperties::Domain"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, Domain) - 328usize];
    // ["Offset of field: _HsaNodeProperties::UniqueID"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, UniqueID) - 332usize];
    // ["Offset of field: _HsaNodeProperties::VGPRSizePerCU"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, VGPRSizePerCU) - 340usize];
    // ["Offset of field: _HsaNodeProperties::SGPRSizePerCU"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, SGPRSizePerCU) - 344usize];
    // ["Offset of field: _HsaNodeProperties::NumXcc"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, NumXcc) - 348usize];
    // ["Offset of field: _HsaNodeProperties::KFDGpuID"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, KFDGpuID) - 352usize];
    // ["Offset of field: _HsaNodeProperties::FamilyID"]
    //     [::std::mem::offset_of!(_HsaNodeProperties, FamilyID) - 356usize];
};
pub type HsaNodeProperties = _HsaNodeProperties;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_SYSTEM: _HSA_HEAPTYPE = 0;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_FRAME_BUFFER_PUBLIC: _HSA_HEAPTYPE = 1;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_FRAME_BUFFER_PRIVATE: _HSA_HEAPTYPE = 2;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_GPU_GDS: _HSA_HEAPTYPE = 3;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_GPU_LDS: _HSA_HEAPTYPE = 4;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_GPU_SCRATCH: _HSA_HEAPTYPE = 5;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_DEVICE_SVM: _HSA_HEAPTYPE = 6;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_MMIO_REMAP: _HSA_HEAPTYPE = 7;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_NUMHEAPTYPES: _HSA_HEAPTYPE = 8;
pub const _HSA_HEAPTYPE_HSA_HEAPTYPE_SIZE: _HSA_HEAPTYPE = 4294967295;
pub type _HSA_HEAPTYPE = ::std::os::raw::c_uint;
pub use self::_HSA_HEAPTYPE as HSA_HEAPTYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union HSA_MEMORYPROPERTY {
    pub MemoryProperty: HSAuint32,
    pub ui32: HSA_MEMORYPROPERTY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSA_MEMORYPROPERTY__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_MEMORYPROPERTY__bindgen_ty_1"]
        [::std::mem::size_of::<HSA_MEMORYPROPERTY__bindgen_ty_1>() - 4usize];
    ["Alignment of HSA_MEMORYPROPERTY__bindgen_ty_1"]
        [::std::mem::align_of::<HSA_MEMORYPROPERTY__bindgen_ty_1>() - 4usize];
};
impl HSA_MEMORYPROPERTY__bindgen_ty_1 {
    #[inline]
    pub fn HotPluggable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HotPluggable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HotPluggable_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HotPluggable_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonVolatile(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonVolatile(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonVolatile_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonVolatile_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HotPluggable: ::std::os::raw::c_uint,
        NonVolatile: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HotPluggable: u32 = unsafe { ::std::mem::transmute(HotPluggable) };
            HotPluggable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonVolatile: u32 = unsafe { ::std::mem::transmute(NonVolatile) };
            NonVolatile as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_MEMORYPROPERTY"][::std::mem::size_of::<HSA_MEMORYPROPERTY>() - 4usize];
    ["Alignment of HSA_MEMORYPROPERTY"][::std::mem::align_of::<HSA_MEMORYPROPERTY>() - 4usize];
    ["Offset of field: HSA_MEMORYPROPERTY::MemoryProperty"]
        [::std::mem::offset_of!(HSA_MEMORYPROPERTY, MemoryProperty) - 0usize];
    ["Offset of field: HSA_MEMORYPROPERTY::ui32"]
        [::std::mem::offset_of!(HSA_MEMORYPROPERTY, ui32) - 0usize];
};
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _HsaMemoryProperties {
    pub HeapType: HSA_HEAPTYPE,
    pub __bindgen_anon_1: _HsaMemoryProperties__bindgen_ty_1,
    pub Flags: HSA_MEMORYPROPERTY,
    pub Width: HSAuint32,
    pub MemoryClockMax: HSAuint32,
    pub VirtualBaseAddress: HSAuint64,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union _HsaMemoryProperties__bindgen_ty_1 {
    pub SizeInBytes: HSAuint64,
    pub ui32: _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1 {
    pub SizeInBytesLow: HSAuint32,
    pub SizeInBytesHigh: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1::SizeInBytesLow"][::std::mem::offset_of!(
        _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1,
        SizeInBytesLow
    )
        - 0usize];
    ["Offset of field: _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1::SizeInBytesHigh"][::std::mem::offset_of!(
        _HsaMemoryProperties__bindgen_ty_1__bindgen_ty_1,
        SizeInBytesHigh
    )
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemoryProperties__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaMemoryProperties__bindgen_ty_1>() - 8usize];
    ["Alignment of _HsaMemoryProperties__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaMemoryProperties__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaMemoryProperties__bindgen_ty_1::SizeInBytes"]
        [::std::mem::offset_of!(_HsaMemoryProperties__bindgen_ty_1, SizeInBytes) - 0usize];
    ["Offset of field: _HsaMemoryProperties__bindgen_ty_1::ui32"]
        [::std::mem::offset_of!(_HsaMemoryProperties__bindgen_ty_1, ui32) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemoryProperties"][::std::mem::size_of::<_HsaMemoryProperties>() - 32usize];
    ["Alignment of _HsaMemoryProperties"][::std::mem::align_of::<_HsaMemoryProperties>() - 4usize];
    ["Offset of field: _HsaMemoryProperties::HeapType"]
        [::std::mem::offset_of!(_HsaMemoryProperties, HeapType) - 0usize];
    ["Offset of field: _HsaMemoryProperties::Flags"]
        [::std::mem::offset_of!(_HsaMemoryProperties, Flags) - 12usize];
    ["Offset of field: _HsaMemoryProperties::Width"]
        [::std::mem::offset_of!(_HsaMemoryProperties, Width) - 16usize];
    ["Offset of field: _HsaMemoryProperties::MemoryClockMax"]
        [::std::mem::offset_of!(_HsaMemoryProperties, MemoryClockMax) - 20usize];
    ["Offset of field: _HsaMemoryProperties::VirtualBaseAddress"]
        [::std::mem::offset_of!(_HsaMemoryProperties, VirtualBaseAddress) - 24usize];
};
pub type HsaMemoryProperties = _HsaMemoryProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub union HsaCacheType {
    pub Value: HSAuint32,
    pub ui32: HsaCacheType__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HsaCacheType__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HsaCacheType__bindgen_ty_1"]
        [::std::mem::size_of::<HsaCacheType__bindgen_ty_1>() - 4usize];
    ["Alignment of HsaCacheType__bindgen_ty_1"]
        [::std::mem::align_of::<HsaCacheType__bindgen_ty_1>() - 4usize];
};
impl HsaCacheType__bindgen_ty_1 {
    #[inline]
    pub fn Data(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Data(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Data_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Data_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Instruction(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Instruction(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Instruction_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Instruction_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CPU(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPU(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CPU_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CPU_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HSACU(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HSACU(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HSACU_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HSACU_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Data: ::std::os::raw::c_uint,
        Instruction: ::std::os::raw::c_uint,
        CPU: ::std::os::raw::c_uint,
        HSACU: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Data: u32 = unsafe { ::std::mem::transmute(Data) };
            Data as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Instruction: u32 = unsafe { ::std::mem::transmute(Instruction) };
            Instruction as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CPU: u32 = unsafe { ::std::mem::transmute(CPU) };
            CPU as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let HSACU: u32 = unsafe { ::std::mem::transmute(HSACU) };
            HSACU as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HsaCacheType"][::std::mem::size_of::<HsaCacheType>() - 4usize];
    ["Alignment of HsaCacheType"][::std::mem::align_of::<HsaCacheType>() - 4usize];
    ["Offset of field: HsaCacheType::Value"][::std::mem::offset_of!(HsaCacheType, Value) - 0usize];
    ["Offset of field: HsaCacheType::ui32"][::std::mem::offset_of!(HsaCacheType, ui32) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HaCacheProperties {
    pub ProcessorIdLow: HSAuint32,
    pub CacheLevel: HSAuint32,
    pub CacheSize: HSAuint32,
    pub CacheLineSize: HSAuint32,
    pub CacheLinesPerTag: HSAuint32,
    pub CacheAssociativity: HSAuint32,
    pub CacheLatency: HSAuint32,
    pub CacheType: HsaCacheType,
    pub SiblingMap: [HSAuint32; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HaCacheProperties"][::std::mem::size_of::<_HaCacheProperties>() - 1056usize];
    ["Alignment of _HaCacheProperties"][::std::mem::align_of::<_HaCacheProperties>() - 4usize];
    ["Offset of field: _HaCacheProperties::ProcessorIdLow"]
        [::std::mem::offset_of!(_HaCacheProperties, ProcessorIdLow) - 0usize];
    ["Offset of field: _HaCacheProperties::CacheLevel"]
        [::std::mem::offset_of!(_HaCacheProperties, CacheLevel) - 4usize];
    ["Offset of field: _HaCacheProperties::CacheSize"]
        [::std::mem::offset_of!(_HaCacheProperties, CacheSize) - 8usize];
    ["Offset of field: _HaCacheProperties::CacheLineSize"]
        [::std::mem::offset_of!(_HaCacheProperties, CacheLineSize) - 12usize];
    ["Offset of field: _HaCacheProperties::CacheLinesPerTag"]
        [::std::mem::offset_of!(_HaCacheProperties, CacheLinesPerTag) - 16usize];
    ["Offset of field: _HaCacheProperties::CacheAssociativity"]
        [::std::mem::offset_of!(_HaCacheProperties, CacheAssociativity) - 20usize];
    ["Offset of field: _HaCacheProperties::CacheLatency"]
        [::std::mem::offset_of!(_HaCacheProperties, CacheLatency) - 24usize];
    ["Offset of field: _HaCacheProperties::CacheType"]
        [::std::mem::offset_of!(_HaCacheProperties, CacheType) - 28usize];
    ["Offset of field: _HaCacheProperties::SiblingMap"]
        [::std::mem::offset_of!(_HaCacheProperties, SiblingMap) - 32usize];
};
pub type HsaCacheProperties = _HaCacheProperties;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaCComputeProperties {
    pub SiblingMap: [HSAuint32; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaCComputeProperties"][::std::mem::size_of::<_HsaCComputeProperties>() - 1024usize];
    ["Alignment of _HsaCComputeProperties"]
        [::std::mem::align_of::<_HsaCComputeProperties>() - 4usize];
    ["Offset of field: _HsaCComputeProperties::SiblingMap"]
        [::std::mem::offset_of!(_HsaCComputeProperties, SiblingMap) - 0usize];
};
pub type HsaCComputeProperties = _HsaCComputeProperties;
pub const _HSA_IOLINKTYPE_HSA_IOLINKTYPE_UNDEFINED: _HSA_IOLINKTYPE = 0;
pub const _HSA_IOLINKTYPE_HSA_IOLINKTYPE_HYPERTRANSPORT: _HSA_IOLINKTYPE = 1;
pub const _HSA_IOLINKTYPE_HSA_IOLINKTYPE_PCIEXPRESS: _HSA_IOLINKTYPE = 2;
pub const _HSA_IOLINKTYPE_HSA_IOLINKTYPE_AMBA: _HSA_IOLINKTYPE = 3;
pub const _HSA_IOLINKTYPE_HSA_IOLINKTYPE_MIPI: _HSA_IOLINKTYPE = 4;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_QPI_1_1: _HSA_IOLINKTYPE = 5;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_RESERVED1: _HSA_IOLINKTYPE = 6;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_RESERVED2: _HSA_IOLINKTYPE = 7;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_RAPID_IO: _HSA_IOLINKTYPE = 8;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_INFINIBAND: _HSA_IOLINKTYPE = 9;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_RESERVED3: _HSA_IOLINKTYPE = 10;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_XGMI: _HSA_IOLINKTYPE = 11;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_XGOP: _HSA_IOLINKTYPE = 12;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_GZ: _HSA_IOLINKTYPE = 13;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_ETHERNET_RDMA: _HSA_IOLINKTYPE = 14;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_RDMA_OTHER: _HSA_IOLINKTYPE = 15;
pub const _HSA_IOLINKTYPE_HSA_IOLINK_TYPE_OTHER: _HSA_IOLINKTYPE = 16;
pub const _HSA_IOLINKTYPE_HSA_IOLINKTYPE_NUMIOLINKTYPES: _HSA_IOLINKTYPE = 17;
pub const _HSA_IOLINKTYPE_HSA_IOLINKTYPE_SIZE: _HSA_IOLINKTYPE = 4294967295;
pub type _HSA_IOLINKTYPE = ::std::os::raw::c_uint;
pub use self::_HSA_IOLINKTYPE as HSA_IOLINKTYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union HSA_LINKPROPERTY {
    pub LinkProperty: HSAuint32,
    pub ui32: HSA_LINKPROPERTY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSA_LINKPROPERTY__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_LINKPROPERTY__bindgen_ty_1"]
        [::std::mem::size_of::<HSA_LINKPROPERTY__bindgen_ty_1>() - 4usize];
    ["Alignment of HSA_LINKPROPERTY__bindgen_ty_1"]
        [::std::mem::align_of::<HSA_LINKPROPERTY__bindgen_ty_1>() - 4usize];
};
impl HSA_LINKPROPERTY__bindgen_ty_1 {
    #[inline]
    pub fn Override(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Override(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Override_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Override_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NonCoherent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonCoherent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonCoherent_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonCoherent_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoAtomics32bit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoAtomics32bit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoAtomics32bit_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoAtomics32bit_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoAtomics64bit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoAtomics64bit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoAtomics64bit_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoAtomics64bit_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoPeerToPeerDMA(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoPeerToPeerDMA(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoPeerToPeerDMA_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoPeerToPeerDMA_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                27u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                27u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Override: ::std::os::raw::c_uint,
        NonCoherent: ::std::os::raw::c_uint,
        NoAtomics32bit: ::std::os::raw::c_uint,
        NoAtomics64bit: ::std::os::raw::c_uint,
        NoPeerToPeerDMA: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Override: u32 = unsafe { ::std::mem::transmute(Override) };
            Override as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NonCoherent: u32 = unsafe { ::std::mem::transmute(NonCoherent) };
            NonCoherent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NoAtomics32bit: u32 = unsafe { ::std::mem::transmute(NoAtomics32bit) };
            NoAtomics32bit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NoAtomics64bit: u32 = unsafe { ::std::mem::transmute(NoAtomics64bit) };
            NoAtomics64bit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NoPeerToPeerDMA: u32 = unsafe { ::std::mem::transmute(NoPeerToPeerDMA) };
            NoPeerToPeerDMA as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_LINKPROPERTY"][::std::mem::size_of::<HSA_LINKPROPERTY>() - 4usize];
    ["Alignment of HSA_LINKPROPERTY"][::std::mem::align_of::<HSA_LINKPROPERTY>() - 4usize];
    ["Offset of field: HSA_LINKPROPERTY::LinkProperty"]
        [::std::mem::offset_of!(HSA_LINKPROPERTY, LinkProperty) - 0usize];
    ["Offset of field: HSA_LINKPROPERTY::ui32"]
        [::std::mem::offset_of!(HSA_LINKPROPERTY, ui32) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaIoLinkProperties {
    pub IoLinkType: HSA_IOLINKTYPE,
    pub VersionMajor: HSAuint32,
    pub VersionMinor: HSAuint32,
    pub NodeFrom: HSAuint32,
    pub NodeTo: HSAuint32,
    pub Weight: HSAuint32,
    pub MinimumLatency: HSAuint32,
    pub MaximumLatency: HSAuint32,
    pub MinimumBandwidth: HSAuint32,
    pub MaximumBandwidth: HSAuint32,
    pub RecTransferSize: HSAuint32,
    pub RecSdmaEngIdMask: HSAuint32,
    pub Flags: HSA_LINKPROPERTY,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaIoLinkProperties"][::std::mem::size_of::<_HsaIoLinkProperties>() - 52usize];
    ["Alignment of _HsaIoLinkProperties"][::std::mem::align_of::<_HsaIoLinkProperties>() - 4usize];
    ["Offset of field: _HsaIoLinkProperties::IoLinkType"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, IoLinkType) - 0usize];
    ["Offset of field: _HsaIoLinkProperties::VersionMajor"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, VersionMajor) - 4usize];
    ["Offset of field: _HsaIoLinkProperties::VersionMinor"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, VersionMinor) - 8usize];
    ["Offset of field: _HsaIoLinkProperties::NodeFrom"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, NodeFrom) - 12usize];
    ["Offset of field: _HsaIoLinkProperties::NodeTo"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, NodeTo) - 16usize];
    ["Offset of field: _HsaIoLinkProperties::Weight"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, Weight) - 20usize];
    ["Offset of field: _HsaIoLinkProperties::MinimumLatency"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, MinimumLatency) - 24usize];
    ["Offset of field: _HsaIoLinkProperties::MaximumLatency"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, MaximumLatency) - 28usize];
    ["Offset of field: _HsaIoLinkProperties::MinimumBandwidth"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, MinimumBandwidth) - 32usize];
    ["Offset of field: _HsaIoLinkProperties::MaximumBandwidth"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, MaximumBandwidth) - 36usize];
    ["Offset of field: _HsaIoLinkProperties::RecTransferSize"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, RecTransferSize) - 40usize];
    ["Offset of field: _HsaIoLinkProperties::RecSdmaEngIdMask"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, RecSdmaEngIdMask) - 44usize];
    ["Offset of field: _HsaIoLinkProperties::Flags"]
        [::std::mem::offset_of!(_HsaIoLinkProperties, Flags) - 48usize];
};
pub type HsaIoLinkProperties = _HsaIoLinkProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaMemFlags {
    pub __bindgen_anon_1: _HsaMemFlags__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HsaMemFlags__bindgen_ty_1 {
    pub ui32: _HsaMemFlags__bindgen_ty_1__bindgen_ty_1,
    pub Value: HSAuint32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaMemFlags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemFlags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaMemFlags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of _HsaMemFlags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaMemFlags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl _HsaMemFlags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NonPaged(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonPaged(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NonPaged_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NonPaged_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CachePolicy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CachePolicy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CachePolicy_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CachePolicy_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadOnly_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReadOnly_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PageSize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PageSize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PageSize_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PageSize_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HostAccess(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HostAccess(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HostAccess_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HostAccess_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoSubstitute(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoSubstitute(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoSubstitute_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoSubstitute_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GDSMemory(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GDSMemory(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GDSMemory_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_GDSMemory_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Scratch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Scratch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Scratch_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Scratch_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicAccessFull(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicAccessFull(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicAccessFull_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicAccessFull_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AtomicAccessPartial(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AtomicAccessPartial(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AtomicAccessPartial_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AtomicAccessPartial_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExecuteAccess(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExecuteAccess(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExecuteAccess_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExecuteAccess_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CoarseGrain(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CoarseGrain(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CoarseGrain_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CoarseGrain_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn AQLQueueMemory(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AQLQueueMemory(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn AQLQueueMemory_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_AQLQueueMemory_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn FixedAddress(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FixedAddress(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn FixedAddress_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_FixedAddress_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoNUMABind(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoNUMABind(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoNUMABind_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoNUMABind_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Uncached(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Uncached(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Uncached_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Uncached_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoAddress(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoAddress(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoAddress_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoAddress_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn OnlyAddress(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OnlyAddress(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn OnlyAddress_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_OnlyAddress_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ExtendedCoherent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedCoherent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ExtendedCoherent_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ExtendedCoherent_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GTTAccess(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GTTAccess(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GTTAccess_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_GTTAccess_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Contiguous(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Contiguous(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Contiguous_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Contiguous_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                9u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NonPaged: ::std::os::raw::c_uint,
        CachePolicy: ::std::os::raw::c_uint,
        ReadOnly: ::std::os::raw::c_uint,
        PageSize: ::std::os::raw::c_uint,
        HostAccess: ::std::os::raw::c_uint,
        NoSubstitute: ::std::os::raw::c_uint,
        GDSMemory: ::std::os::raw::c_uint,
        Scratch: ::std::os::raw::c_uint,
        AtomicAccessFull: ::std::os::raw::c_uint,
        AtomicAccessPartial: ::std::os::raw::c_uint,
        ExecuteAccess: ::std::os::raw::c_uint,
        CoarseGrain: ::std::os::raw::c_uint,
        AQLQueueMemory: ::std::os::raw::c_uint,
        FixedAddress: ::std::os::raw::c_uint,
        NoNUMABind: ::std::os::raw::c_uint,
        Uncached: ::std::os::raw::c_uint,
        NoAddress: ::std::os::raw::c_uint,
        OnlyAddress: ::std::os::raw::c_uint,
        ExtendedCoherent: ::std::os::raw::c_uint,
        GTTAccess: ::std::os::raw::c_uint,
        Contiguous: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NonPaged: u32 = unsafe { ::std::mem::transmute(NonPaged) };
            NonPaged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let CachePolicy: u32 = unsafe { ::std::mem::transmute(CachePolicy) };
            CachePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let PageSize: u32 = unsafe { ::std::mem::transmute(PageSize) };
            PageSize as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HostAccess: u32 = unsafe { ::std::mem::transmute(HostAccess) };
            HostAccess as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NoSubstitute: u32 = unsafe { ::std::mem::transmute(NoSubstitute) };
            NoSubstitute as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let GDSMemory: u32 = unsafe { ::std::mem::transmute(GDSMemory) };
            GDSMemory as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Scratch: u32 = unsafe { ::std::mem::transmute(Scratch) };
            Scratch as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let AtomicAccessFull: u32 = unsafe { ::std::mem::transmute(AtomicAccessFull) };
            AtomicAccessFull as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AtomicAccessPartial: u32 = unsafe { ::std::mem::transmute(AtomicAccessPartial) };
            AtomicAccessPartial as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ExecuteAccess: u32 = unsafe { ::std::mem::transmute(ExecuteAccess) };
            ExecuteAccess as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let CoarseGrain: u32 = unsafe { ::std::mem::transmute(CoarseGrain) };
            CoarseGrain as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let AQLQueueMemory: u32 = unsafe { ::std::mem::transmute(AQLQueueMemory) };
            AQLQueueMemory as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FixedAddress: u32 = unsafe { ::std::mem::transmute(FixedAddress) };
            FixedAddress as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let NoNUMABind: u32 = unsafe { ::std::mem::transmute(NoNUMABind) };
            NoNUMABind as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Uncached: u32 = unsafe { ::std::mem::transmute(Uncached) };
            Uncached as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let NoAddress: u32 = unsafe { ::std::mem::transmute(NoAddress) };
            NoAddress as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let OnlyAddress: u32 = unsafe { ::std::mem::transmute(OnlyAddress) };
            OnlyAddress as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ExtendedCoherent: u32 = unsafe { ::std::mem::transmute(ExtendedCoherent) };
            ExtendedCoherent as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let GTTAccess: u32 = unsafe { ::std::mem::transmute(GTTAccess) };
            GTTAccess as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Contiguous: u32 = unsafe { ::std::mem::transmute(Contiguous) };
            Contiguous as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemFlags__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaMemFlags__bindgen_ty_1>() - 4usize];
    ["Alignment of _HsaMemFlags__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaMemFlags__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaMemFlags__bindgen_ty_1::ui32"]
        [::std::mem::offset_of!(_HsaMemFlags__bindgen_ty_1, ui32) - 0usize];
    ["Offset of field: _HsaMemFlags__bindgen_ty_1::Value"]
        [::std::mem::offset_of!(_HsaMemFlags__bindgen_ty_1, Value) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemFlags"][::std::mem::size_of::<_HsaMemFlags>() - 4usize];
    ["Alignment of _HsaMemFlags"][::std::mem::align_of::<_HsaMemFlags>() - 4usize];
};
pub type HsaMemFlags = _HsaMemFlags;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaMemMapFlags {
    pub __bindgen_anon_1: _HsaMemMapFlags__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HsaMemMapFlags__bindgen_ty_1 {
    pub ui32: _HsaMemMapFlags__bindgen_ty_1__bindgen_ty_1,
    pub Value: HSAuint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaMemMapFlags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemMapFlags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaMemMapFlags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of _HsaMemMapFlags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaMemMapFlags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl _HsaMemMapFlags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved1_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved1_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn CachePolicy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CachePolicy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn CachePolicy_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_CachePolicy_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadOnly_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReadOnly_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn PageSize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PageSize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn PageSize_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_PageSize_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn HostAccess(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HostAccess(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn HostAccess_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_HostAccess_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Migrate(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Migrate(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Migrate_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Migrate_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Probe(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Probe(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Probe_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Probe_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ::std::os::raw::c_uint,
        CachePolicy: ::std::os::raw::c_uint,
        ReadOnly: ::std::os::raw::c_uint,
        PageSize: ::std::os::raw::c_uint,
        HostAccess: ::std::os::raw::c_uint,
        Migrate: ::std::os::raw::c_uint,
        Probe: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let CachePolicy: u32 = unsafe { ::std::mem::transmute(CachePolicy) };
            CachePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let PageSize: u32 = unsafe { ::std::mem::transmute(PageSize) };
            PageSize as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HostAccess: u32 = unsafe { ::std::mem::transmute(HostAccess) };
            HostAccess as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Migrate: u32 = unsafe { ::std::mem::transmute(Migrate) };
            Migrate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Probe: u32 = unsafe { ::std::mem::transmute(Probe) };
            Probe as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemMapFlags__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaMemMapFlags__bindgen_ty_1>() - 4usize];
    ["Alignment of _HsaMemMapFlags__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaMemMapFlags__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaMemMapFlags__bindgen_ty_1::ui32"]
        [::std::mem::offset_of!(_HsaMemMapFlags__bindgen_ty_1, ui32) - 0usize];
    ["Offset of field: _HsaMemMapFlags__bindgen_ty_1::Value"]
        [::std::mem::offset_of!(_HsaMemMapFlags__bindgen_ty_1, Value) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemMapFlags"][::std::mem::size_of::<_HsaMemMapFlags>() - 4usize];
    ["Alignment of _HsaMemMapFlags"][::std::mem::align_of::<_HsaMemMapFlags>() - 4usize];
};
pub type HsaMemMapFlags = _HsaMemMapFlags;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaGraphicsResourceInfo {
    pub MemoryAddress: *mut ::std::os::raw::c_void,
    pub SizeInBytes: HSAuint64,
    pub Metadata: *const ::std::os::raw::c_void,
    pub MetadataSizeInBytes: HSAuint32,
    pub NodeId: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaGraphicsResourceInfo"]
        [::std::mem::size_of::<_HsaGraphicsResourceInfo>() - 32usize];
    ["Alignment of _HsaGraphicsResourceInfo"]
        [::std::mem::align_of::<_HsaGraphicsResourceInfo>() - 4usize];
    ["Offset of field: _HsaGraphicsResourceInfo::MemoryAddress"]
        [::std::mem::offset_of!(_HsaGraphicsResourceInfo, MemoryAddress) - 0usize];
    ["Offset of field: _HsaGraphicsResourceInfo::SizeInBytes"]
        [::std::mem::offset_of!(_HsaGraphicsResourceInfo, SizeInBytes) - 8usize];
    ["Offset of field: _HsaGraphicsResourceInfo::Metadata"]
        [::std::mem::offset_of!(_HsaGraphicsResourceInfo, Metadata) - 16usize];
    ["Offset of field: _HsaGraphicsResourceInfo::MetadataSizeInBytes"]
        [::std::mem::offset_of!(_HsaGraphicsResourceInfo, MetadataSizeInBytes) - 24usize];
    ["Offset of field: _HsaGraphicsResourceInfo::NodeId"]
        [::std::mem::offset_of!(_HsaGraphicsResourceInfo, NodeId) - 28usize];
};
pub type HsaGraphicsResourceInfo = _HsaGraphicsResourceInfo;
pub const _HSA_CACHING_TYPE_HSA_CACHING_CACHED: _HSA_CACHING_TYPE = 0;
pub const _HSA_CACHING_TYPE_HSA_CACHING_NONCACHED: _HSA_CACHING_TYPE = 1;
pub const _HSA_CACHING_TYPE_HSA_CACHING_WRITECOMBINED: _HSA_CACHING_TYPE = 2;
pub const _HSA_CACHING_TYPE_HSA_CACHING_RESERVED: _HSA_CACHING_TYPE = 3;
pub const _HSA_CACHING_TYPE_HSA_CACHING_NUM_CACHING: _HSA_CACHING_TYPE = 4;
pub const _HSA_CACHING_TYPE_HSA_CACHING_SIZE: _HSA_CACHING_TYPE = 4294967295;
pub type _HSA_CACHING_TYPE = ::std::os::raw::c_uint;
pub use self::_HSA_CACHING_TYPE as HSA_CACHING_TYPE;
pub const _HSA_PAGE_SIZE_HSA_PAGE_SIZE_4KB: _HSA_PAGE_SIZE = 0;
pub const _HSA_PAGE_SIZE_HSA_PAGE_SIZE_64KB: _HSA_PAGE_SIZE = 1;
pub const _HSA_PAGE_SIZE_HSA_PAGE_SIZE_2MB: _HSA_PAGE_SIZE = 2;
pub const _HSA_PAGE_SIZE_HSA_PAGE_SIZE_1GB: _HSA_PAGE_SIZE = 3;
pub type _HSA_PAGE_SIZE = ::std::os::raw::c_uint;
pub use self::_HSA_PAGE_SIZE as HSA_PAGE_SIZE;
pub const _HSA_DEVICE_HSA_DEVICE_CPU: _HSA_DEVICE = 0;
pub const _HSA_DEVICE_HSA_DEVICE_GPU: _HSA_DEVICE = 1;
pub const _HSA_DEVICE_MAX_HSA_DEVICE: _HSA_DEVICE = 2;
pub type _HSA_DEVICE = ::std::os::raw::c_uint;
pub use self::_HSA_DEVICE as HSA_DEVICE;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_MINIMUM: _HSA_QUEUE_PRIORITY = -3;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_LOW: _HSA_QUEUE_PRIORITY = -2;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_BELOW_NORMAL: _HSA_QUEUE_PRIORITY = -1;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_NORMAL: _HSA_QUEUE_PRIORITY = 0;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_ABOVE_NORMAL: _HSA_QUEUE_PRIORITY = 1;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_HIGH: _HSA_QUEUE_PRIORITY = 2;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_MAXIMUM: _HSA_QUEUE_PRIORITY = 3;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_NUM_PRIORITY: _HSA_QUEUE_PRIORITY = 4;
pub const _HSA_QUEUE_PRIORITY_HSA_QUEUE_PRIORITY_SIZE: _HSA_QUEUE_PRIORITY = 4294967295;
pub type _HSA_QUEUE_PRIORITY = ::std::os::raw::c_long;
pub use self::_HSA_QUEUE_PRIORITY as HSA_QUEUE_PRIORITY;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_COMPUTE: _HSA_QUEUE_TYPE = 1;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_SDMA: _HSA_QUEUE_TYPE = 2;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_MULTIMEDIA_DECODE: _HSA_QUEUE_TYPE = 3;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_MULTIMEDIA_ENCODE: _HSA_QUEUE_TYPE = 4;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_SDMA_XGMI: _HSA_QUEUE_TYPE = 5;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_SDMA_BY_ENG_ID: _HSA_QUEUE_TYPE = 6;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_COMPUTE_OS: _HSA_QUEUE_TYPE = 11;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_SDMA_OS: _HSA_QUEUE_TYPE = 12;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_MULTIMEDIA_DECODE_OS: _HSA_QUEUE_TYPE = 13;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_MULTIMEDIA_ENCODE_OS: _HSA_QUEUE_TYPE = 14;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_COMPUTE_AQL: _HSA_QUEUE_TYPE = 21;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_DMA_AQL: _HSA_QUEUE_TYPE = 22;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_DMA_AQL_XGMI: _HSA_QUEUE_TYPE = 23;
pub const _HSA_QUEUE_TYPE_HSA_QUEUE_TYPE_SIZE: _HSA_QUEUE_TYPE = 4294967295;
pub type _HSA_QUEUE_TYPE = ::std::os::raw::c_uint;
pub use self::_HSA_QUEUE_TYPE as HSA_QUEUE_TYPE;
#[doc = "The user context save area is page aligned. The HsaUserContextSaveAreaHeader\nheader starts at offset 0. Space for a user space copy of the control stack\ncomes next and is immediately followed by the user space wave save state. The\nstart of the user space wave save state is page aligned. The debugger reserved\narea comes next and is 64 byte aligned.\n\nThe user context save area is valid for the duration that the associated\nqueue exists. When a context save occurs, the HsaUserContextSaveAreaHeader\nheader will be updated with information about the context save. The context\nsave area is not modified by any other operation, including a context resume."]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HsaUserContextSaveAreaHeader {
    pub ControlStackOffset: HSAuint32,
    pub ControlStackSize: HSAuint32,
    pub WaveStateOffset: HSAuint32,
    pub WaveStateSize: HSAuint32,
    pub DebugOffset: HSAuint32,
    pub DebugSize: HSAuint32,
    pub ErrorReason: *mut HSAint64,
    pub ErrorEventId: HSAuint32,
    pub Reserved1: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HsaUserContextSaveAreaHeader"]
        [::std::mem::size_of::<HsaUserContextSaveAreaHeader>() - 40usize];
    ["Alignment of HsaUserContextSaveAreaHeader"]
        [::std::mem::align_of::<HsaUserContextSaveAreaHeader>() - 4usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::ControlStackOffset"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, ControlStackOffset) - 0usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::ControlStackSize"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, ControlStackSize) - 4usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::WaveStateOffset"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, WaveStateOffset) - 8usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::WaveStateSize"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, WaveStateSize) - 12usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::DebugOffset"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, DebugOffset) - 16usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::DebugSize"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, DebugSize) - 20usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::ErrorReason"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, ErrorReason) - 24usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::ErrorEventId"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, ErrorEventId) - 32usize];
    ["Offset of field: HsaUserContextSaveAreaHeader::Reserved1"]
        [::std::mem::offset_of!(HsaUserContextSaveAreaHeader, Reserved1) - 36usize];
};
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct HsaQueueInfo {
    pub QueueDetailError: HSAuint32,
    pub QueueTypeExtended: HSAuint32,
    pub NumCUAssigned: HSAuint32,
    pub CUMaskInfo: *mut HSAuint32,
    pub UserContextSaveArea: *mut HSAuint32,
    pub SaveAreaSizeInBytes: HSAuint64,
    pub ControlStackTop: *mut HSAuint32,
    pub ControlStackUsedInBytes: HSAuint64,
    pub SaveAreaHeader: *mut HsaUserContextSaveAreaHeader,
    pub Reserved2: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HsaQueueInfo"][::std::mem::size_of::<HsaQueueInfo>() - 68usize];
    ["Alignment of HsaQueueInfo"][::std::mem::align_of::<HsaQueueInfo>() - 4usize];
    ["Offset of field: HsaQueueInfo::QueueDetailError"]
        [::std::mem::offset_of!(HsaQueueInfo, QueueDetailError) - 0usize];
    ["Offset of field: HsaQueueInfo::QueueTypeExtended"]
        [::std::mem::offset_of!(HsaQueueInfo, QueueTypeExtended) - 4usize];
    ["Offset of field: HsaQueueInfo::NumCUAssigned"]
        [::std::mem::offset_of!(HsaQueueInfo, NumCUAssigned) - 8usize];
    ["Offset of field: HsaQueueInfo::CUMaskInfo"]
        [::std::mem::offset_of!(HsaQueueInfo, CUMaskInfo) - 12usize];
    ["Offset of field: HsaQueueInfo::UserContextSaveArea"]
        [::std::mem::offset_of!(HsaQueueInfo, UserContextSaveArea) - 20usize];
    ["Offset of field: HsaQueueInfo::SaveAreaSizeInBytes"]
        [::std::mem::offset_of!(HsaQueueInfo, SaveAreaSizeInBytes) - 28usize];
    ["Offset of field: HsaQueueInfo::ControlStackTop"]
        [::std::mem::offset_of!(HsaQueueInfo, ControlStackTop) - 36usize];
    ["Offset of field: HsaQueueInfo::ControlStackUsedInBytes"]
        [::std::mem::offset_of!(HsaQueueInfo, ControlStackUsedInBytes) - 44usize];
    ["Offset of field: HsaQueueInfo::SaveAreaHeader"]
        [::std::mem::offset_of!(HsaQueueInfo, SaveAreaHeader) - 52usize];
    ["Offset of field: HsaQueueInfo::Reserved2"]
        [::std::mem::offset_of!(HsaQueueInfo, Reserved2) - 60usize];
};
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _HsaQueueResource {
    pub QueueId: HSA_QUEUEID,
    pub __bindgen_anon_1: _HsaQueueResource__bindgen_ty_1,
    pub __bindgen_anon_2: _HsaQueueResource__bindgen_ty_2,
    pub __bindgen_anon_3: _HsaQueueResource__bindgen_ty_3,
    pub ErrorReason: *mut HSAint64,
}
#[doc = " queue ID */\n/** Doorbell address to notify HW of a new dispatch"]
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union _HsaQueueResource__bindgen_ty_1 {
    pub Queue_DoorBell: *mut HSAuint32,
    pub Queue_DoorBell_aql: *mut HSAuint64,
    pub QueueDoorBell: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaQueueResource__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaQueueResource__bindgen_ty_1>() - 8usize];
    ["Alignment of _HsaQueueResource__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaQueueResource__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_1::Queue_DoorBell"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_1, Queue_DoorBell) - 0usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_1::Queue_DoorBell_aql"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_1, Queue_DoorBell_aql) - 0usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_1::QueueDoorBell"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_1, QueueDoorBell) - 0usize];
};
#[doc = " virtual address to notify HW of queue write ptr value"]
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union _HsaQueueResource__bindgen_ty_2 {
    pub Queue_write_ptr: *mut HSAuint32,
    pub Queue_write_ptr_aql: *mut HSAuint64,
    pub QueueWptrValue: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaQueueResource__bindgen_ty_2"]
        [::std::mem::size_of::<_HsaQueueResource__bindgen_ty_2>() - 8usize];
    ["Alignment of _HsaQueueResource__bindgen_ty_2"]
        [::std::mem::align_of::<_HsaQueueResource__bindgen_ty_2>() - 4usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_2::Queue_write_ptr"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_2, Queue_write_ptr) - 0usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_2::Queue_write_ptr_aql"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_2, Queue_write_ptr_aql) - 0usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_2::QueueWptrValue"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_2, QueueWptrValue) - 0usize];
};
#[doc = " virtual address updated by HW to indicate current read location"]
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union _HsaQueueResource__bindgen_ty_3 {
    pub Queue_read_ptr: *mut HSAuint32,
    pub Queue_read_ptr_aql: *mut HSAuint64,
    pub QueueRptrValue: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaQueueResource__bindgen_ty_3"]
        [::std::mem::size_of::<_HsaQueueResource__bindgen_ty_3>() - 8usize];
    ["Alignment of _HsaQueueResource__bindgen_ty_3"]
        [::std::mem::align_of::<_HsaQueueResource__bindgen_ty_3>() - 4usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_3::Queue_read_ptr"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_3, Queue_read_ptr) - 0usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_3::Queue_read_ptr_aql"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_3, Queue_read_ptr_aql) - 0usize];
    ["Offset of field: _HsaQueueResource__bindgen_ty_3::QueueRptrValue"]
        [::std::mem::offset_of!(_HsaQueueResource__bindgen_ty_3, QueueRptrValue) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaQueueResource"][::std::mem::size_of::<_HsaQueueResource>() - 40usize];
    ["Alignment of _HsaQueueResource"][::std::mem::align_of::<_HsaQueueResource>() - 4usize];
    ["Offset of field: _HsaQueueResource::QueueId"]
        [::std::mem::offset_of!(_HsaQueueResource, QueueId) - 0usize];
    ["Offset of field: _HsaQueueResource::ErrorReason"]
        [::std::mem::offset_of!(_HsaQueueResource, ErrorReason) - 32usize];
};
pub type HsaQueueResource = _HsaQueueResource;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaQueueReport {
    pub VMID: HSAuint32,
    pub QueueAddress: *mut ::std::os::raw::c_void,
    pub QueueSize: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaQueueReport"][::std::mem::size_of::<_HsaQueueReport>() - 20usize];
    ["Alignment of _HsaQueueReport"][::std::mem::align_of::<_HsaQueueReport>() - 4usize];
    ["Offset of field: _HsaQueueReport::VMID"]
        [::std::mem::offset_of!(_HsaQueueReport, VMID) - 0usize];
    ["Offset of field: _HsaQueueReport::QueueAddress"]
        [::std::mem::offset_of!(_HsaQueueReport, QueueAddress) - 4usize];
    ["Offset of field: _HsaQueueReport::QueueSize"]
        [::std::mem::offset_of!(_HsaQueueReport, QueueSize) - 12usize];
};
pub type HsaQueueReport = _HsaQueueReport;
pub const _HSA_DBG_WAVEOP_HSA_DBG_WAVEOP_HALT: _HSA_DBG_WAVEOP = 1;
pub const _HSA_DBG_WAVEOP_HSA_DBG_WAVEOP_RESUME: _HSA_DBG_WAVEOP = 2;
pub const _HSA_DBG_WAVEOP_HSA_DBG_WAVEOP_KILL: _HSA_DBG_WAVEOP = 3;
pub const _HSA_DBG_WAVEOP_HSA_DBG_WAVEOP_DEBUG: _HSA_DBG_WAVEOP = 4;
pub const _HSA_DBG_WAVEOP_HSA_DBG_WAVEOP_TRAP: _HSA_DBG_WAVEOP = 5;
pub const _HSA_DBG_WAVEOP_HSA_DBG_NUM_WAVEOP: _HSA_DBG_WAVEOP = 5;
pub const _HSA_DBG_WAVEOP_HSA_DBG_MAX_WAVEOP: _HSA_DBG_WAVEOP = 4294967295;
pub type _HSA_DBG_WAVEOP = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_WAVEOP as HSA_DBG_WAVEOP;
pub const _HSA_DBG_WAVEMODE_HSA_DBG_WAVEMODE_SINGLE: _HSA_DBG_WAVEMODE = 0;
pub const _HSA_DBG_WAVEMODE_HSA_DBG_WAVEMODE_BROADCAST_PROCESS: _HSA_DBG_WAVEMODE = 2;
pub const _HSA_DBG_WAVEMODE_HSA_DBG_WAVEMODE_BROADCAST_PROCESS_CU: _HSA_DBG_WAVEMODE = 3;
pub const _HSA_DBG_WAVEMODE_HSA_DBG_NUM_WAVEMODE: _HSA_DBG_WAVEMODE = 3;
pub const _HSA_DBG_WAVEMODE_HSA_DBG_MAX_WAVEMODE: _HSA_DBG_WAVEMODE = 4294967295;
pub type _HSA_DBG_WAVEMODE = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_WAVEMODE as HSA_DBG_WAVEMODE;
pub const _HSA_DBG_WAVEMSG_TYPE_HSA_DBG_WAVEMSG_AUTO: _HSA_DBG_WAVEMSG_TYPE = 0;
pub const _HSA_DBG_WAVEMSG_TYPE_HSA_DBG_WAVEMSG_USER: _HSA_DBG_WAVEMSG_TYPE = 1;
pub const _HSA_DBG_WAVEMSG_TYPE_HSA_DBG_WAVEMSG_ERROR: _HSA_DBG_WAVEMSG_TYPE = 2;
pub const _HSA_DBG_WAVEMSG_TYPE_HSA_DBG_NUM_WAVEMSG: _HSA_DBG_WAVEMSG_TYPE = 3;
pub const _HSA_DBG_WAVEMSG_TYPE_HSA_DBG_MAX_WAVEMSG: _HSA_DBG_WAVEMSG_TYPE = 4294967295;
pub type _HSA_DBG_WAVEMSG_TYPE = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_WAVEMSG_TYPE as HSA_DBG_WAVEMSG_TYPE;
pub const _HSA_DBG_WATCH_MODE_HSA_DBG_WATCH_READ: _HSA_DBG_WATCH_MODE = 0;
pub const _HSA_DBG_WATCH_MODE_HSA_DBG_WATCH_NONREAD: _HSA_DBG_WATCH_MODE = 1;
pub const _HSA_DBG_WATCH_MODE_HSA_DBG_WATCH_ATOMIC: _HSA_DBG_WATCH_MODE = 2;
pub const _HSA_DBG_WATCH_MODE_HSA_DBG_WATCH_ALL: _HSA_DBG_WATCH_MODE = 3;
pub const _HSA_DBG_WATCH_MODE_HSA_DBG_WATCH_NUM: _HSA_DBG_WATCH_MODE = 4;
pub type _HSA_DBG_WATCH_MODE = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_WATCH_MODE as HSA_DBG_WATCH_MODE;
pub const _HSA_DBG_TRAP_OVERRIDE_HSA_DBG_TRAP_OVERRIDE_OR: _HSA_DBG_TRAP_OVERRIDE = 0;
pub const _HSA_DBG_TRAP_OVERRIDE_HSA_DBG_TRAP_OVERRIDE_REPLACE: _HSA_DBG_TRAP_OVERRIDE = 1;
pub const _HSA_DBG_TRAP_OVERRIDE_HSA_DBG_TRAP_OVERRIDE_NUM: _HSA_DBG_TRAP_OVERRIDE = 2;
pub type _HSA_DBG_TRAP_OVERRIDE = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_TRAP_OVERRIDE as HSA_DBG_TRAP_OVERRIDE;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_FP_INVALID: _HSA_DBG_TRAP_MASK = 1;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_FP_INPUT_DENOMAL: _HSA_DBG_TRAP_MASK = 2;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_FP_DIVIDE_BY_ZERO: _HSA_DBG_TRAP_MASK = 4;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_FP_OVERFLOW: _HSA_DBG_TRAP_MASK = 8;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_FP_UNDERFLOW: _HSA_DBG_TRAP_MASK = 16;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_FP_INEXACT: _HSA_DBG_TRAP_MASK = 32;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_INT_DIVIDE_BY_ZERO: _HSA_DBG_TRAP_MASK = 64;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_DBG_ADDRESS_WATCH: _HSA_DBG_TRAP_MASK = 128;
pub const _HSA_DBG_TRAP_MASK_HSA_DBG_TRAP_MASK_DBG_MEMORY_VIOLATION: _HSA_DBG_TRAP_MASK = 256;
pub type _HSA_DBG_TRAP_MASK = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_TRAP_MASK as HSA_DBG_TRAP_MASK;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_NONE: _HSA_DBG_TRAP_EXCEPTION_CODE = 0;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_WAVE_ABORT: _HSA_DBG_TRAP_EXCEPTION_CODE =
    1;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_WAVE_TRAP: _HSA_DBG_TRAP_EXCEPTION_CODE = 2;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_WAVE_MATH_ERROR:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 3;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_WAVE_ILLEGAL_INSTRUCTION:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 4;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_WAVE_MEMORY_VIOLATION:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 5;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_WAVE_APERTURE_VIOLATION:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 6;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_DISPATCH_DIM_INVALID:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 16;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_DISPATCH_GROUP_SEGMENT_SIZE_INVALID : _HSA_DBG_TRAP_EXCEPTION_CODE = 17 ;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_DISPATCH_CODE_INVALID:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 18;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_RESERVED:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 19;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_UNSUPPORTED:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 20;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_DISPATCH_WORK_GROUP_SIZE_INVALID:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 21;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_DISPATCH_REGISTER_INVALID:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 22;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PACKET_VENDOR_UNSUPPORTED:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 23;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_PREEMPTION_ERROR:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 30;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_QUEUE_NEW: _HSA_DBG_TRAP_EXCEPTION_CODE = 31;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_DEVICE_QUEUE_DELETE:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 32;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_DEVICE_MEMORY_VIOLATION:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 33;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_DEVICE_RAS_ERROR: _HSA_DBG_TRAP_EXCEPTION_CODE =
    34;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_DEVICE_FATAL_HALT: _HSA_DBG_TRAP_EXCEPTION_CODE =
    35;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_DEVICE_NEW: _HSA_DBG_TRAP_EXCEPTION_CODE = 36;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_PROCESS_RUNTIME: _HSA_DBG_TRAP_EXCEPTION_CODE =
    48;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_PROCESS_DEVICE_REMOVE:
    _HSA_DBG_TRAP_EXCEPTION_CODE = 49;
pub const _HSA_DBG_TRAP_EXCEPTION_CODE_HSA_DBG_EC_MAX: _HSA_DBG_TRAP_EXCEPTION_CODE = 50;
pub type _HSA_DBG_TRAP_EXCEPTION_CODE = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_TRAP_EXCEPTION_CODE as HSA_DBG_TRAP_EXCEPTION_CODE;
pub const _HSA_DBG_WAVE_LAUNCH_MODE_HSA_DBG_WAVE_LAUNCH_MODE_NORMAL: _HSA_DBG_WAVE_LAUNCH_MODE = 0;
pub const _HSA_DBG_WAVE_LAUNCH_MODE_HSA_DBG_WAVE_LAUNCH_MODE_HALT: _HSA_DBG_WAVE_LAUNCH_MODE = 1;
pub const _HSA_DBG_WAVE_LAUNCH_MODE_HSA_DBG_WAVE_LAUNCH_MODE_KILL: _HSA_DBG_WAVE_LAUNCH_MODE = 2;
pub const _HSA_DBG_WAVE_LAUNCH_MODE_HSA_DBG_WAVE_LAUNCH_MODE_SINGLE_STEP:
    _HSA_DBG_WAVE_LAUNCH_MODE = 3;
pub const _HSA_DBG_WAVE_LAUNCH_MODE_HSA_DBG_WAVE_LAUNCH_MODE_DISABLE: _HSA_DBG_WAVE_LAUNCH_MODE = 4;
pub const _HSA_DBG_WAVE_LAUNCH_MODE_HSA_DBG_WAVE_LAUNCH_MODE_NUM: _HSA_DBG_WAVE_LAUNCH_MODE = 5;
pub type _HSA_DBG_WAVE_LAUNCH_MODE = ::std::os::raw::c_uint;
pub use self::_HSA_DBG_WAVE_LAUNCH_MODE as HSA_DBG_WAVE_LAUNCH_MODE;
pub const HSA_DBG_NODE_CONTROL_HSA_DBG_NODE_CONTROL_FLAG_MAX: HSA_DBG_NODE_CONTROL = 1;
#[doc = "    There are no flags currently defined."]
pub type HSA_DBG_NODE_CONTROL = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaDbgWaveMsgAMDGen2 {
    pub Value: HSAuint32,
    pub Reserved2: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaDbgWaveMsgAMDGen2"][::std::mem::size_of::<_HsaDbgWaveMsgAMDGen2>() - 8usize];
    ["Alignment of _HsaDbgWaveMsgAMDGen2"]
        [::std::mem::align_of::<_HsaDbgWaveMsgAMDGen2>() - 4usize];
    ["Offset of field: _HsaDbgWaveMsgAMDGen2::Value"]
        [::std::mem::offset_of!(_HsaDbgWaveMsgAMDGen2, Value) - 0usize];
    ["Offset of field: _HsaDbgWaveMsgAMDGen2::Reserved2"]
        [::std::mem::offset_of!(_HsaDbgWaveMsgAMDGen2, Reserved2) - 4usize];
};
pub type HsaDbgWaveMsgAMDGen2 = _HsaDbgWaveMsgAMDGen2;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HsaDbgWaveMessageAMD {
    pub WaveMsgInfoGen2: HsaDbgWaveMsgAMDGen2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaDbgWaveMessageAMD"][::std::mem::size_of::<_HsaDbgWaveMessageAMD>() - 8usize];
    ["Alignment of _HsaDbgWaveMessageAMD"]
        [::std::mem::align_of::<_HsaDbgWaveMessageAMD>() - 4usize];
    ["Offset of field: _HsaDbgWaveMessageAMD::WaveMsgInfoGen2"]
        [::std::mem::offset_of!(_HsaDbgWaveMessageAMD, WaveMsgInfoGen2) - 0usize];
};
pub type HsaDbgWaveMessageAMD = _HsaDbgWaveMessageAMD;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _HsaDbgWaveMessage {
    pub MemoryVA: *mut ::std::os::raw::c_void,
    pub DbgWaveMsg: HsaDbgWaveMessageAMD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaDbgWaveMessage"][::std::mem::size_of::<_HsaDbgWaveMessage>() - 16usize];
    ["Alignment of _HsaDbgWaveMessage"][::std::mem::align_of::<_HsaDbgWaveMessage>() - 4usize];
    ["Offset of field: _HsaDbgWaveMessage::MemoryVA"]
        [::std::mem::offset_of!(_HsaDbgWaveMessage, MemoryVA) - 0usize];
    ["Offset of field: _HsaDbgWaveMessage::DbgWaveMsg"]
        [::std::mem::offset_of!(_HsaDbgWaveMessage, DbgWaveMsg) - 8usize];
};
pub type HsaDbgWaveMessage = _HsaDbgWaveMessage;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_SIGNAL: _HSA_EVENTTYPE = 0;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_NODECHANGE: _HSA_EVENTTYPE = 1;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_DEVICESTATECHANGE: _HSA_EVENTTYPE = 2;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_HW_EXCEPTION: _HSA_EVENTTYPE = 3;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_SYSTEM_EVENT: _HSA_EVENTTYPE = 4;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_DEBUG_EVENT: _HSA_EVENTTYPE = 5;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_PROFILE_EVENT: _HSA_EVENTTYPE = 6;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_QUEUE_EVENT: _HSA_EVENTTYPE = 7;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_MEMORY: _HSA_EVENTTYPE = 8;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_MAXID: _HSA_EVENTTYPE = 9;
pub const _HSA_EVENTTYPE_HSA_EVENTTYPE_TYPE_SIZE: _HSA_EVENTTYPE = 4294967295;
pub type _HSA_EVENTTYPE = ::std::os::raw::c_uint;
pub use self::_HSA_EVENTTYPE as HSA_EVENTTYPE;
pub const _HSA_DEBUG_EVENT_TYPE_HSA_DEBUG_EVENT_TYPE_NONE: _HSA_DEBUG_EVENT_TYPE = 0;
pub const _HSA_DEBUG_EVENT_TYPE_HSA_DEBUG_EVENT_TYPE_TRAP: _HSA_DEBUG_EVENT_TYPE = 1;
pub const _HSA_DEBUG_EVENT_TYPE_HSA_DEBUG_EVENT_TYPE_VMFAULT: _HSA_DEBUG_EVENT_TYPE = 2;
pub const _HSA_DEBUG_EVENT_TYPE_HSA_DEBUG_EVENT_TYPE_TRAP_VMFAULT: _HSA_DEBUG_EVENT_TYPE = 3;
pub type _HSA_DEBUG_EVENT_TYPE = ::std::os::raw::c_uint;
pub use self::_HSA_DEBUG_EVENT_TYPE as HSA_DEBUG_EVENT_TYPE;
pub type HSA_EVENTID = HSAuint32;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _HsaSyncVar {
    pub SyncVar: _HsaSyncVar__bindgen_ty_1,
    pub SyncVarSize: HSAuint64,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union _HsaSyncVar__bindgen_ty_1 {
    pub UserData: *mut ::std::os::raw::c_void,
    pub UserDataPtrValue: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaSyncVar__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaSyncVar__bindgen_ty_1>() - 8usize];
    ["Alignment of _HsaSyncVar__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaSyncVar__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaSyncVar__bindgen_ty_1::UserData"]
        [::std::mem::offset_of!(_HsaSyncVar__bindgen_ty_1, UserData) - 0usize];
    ["Offset of field: _HsaSyncVar__bindgen_ty_1::UserDataPtrValue"]
        [::std::mem::offset_of!(_HsaSyncVar__bindgen_ty_1, UserDataPtrValue) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaSyncVar"][::std::mem::size_of::<_HsaSyncVar>() - 16usize];
    ["Alignment of _HsaSyncVar"][::std::mem::align_of::<_HsaSyncVar>() - 4usize];
    ["Offset of field: _HsaSyncVar::SyncVar"]
        [::std::mem::offset_of!(_HsaSyncVar, SyncVar) - 0usize];
    ["Offset of field: _HsaSyncVar::SyncVarSize"]
        [::std::mem::offset_of!(_HsaSyncVar, SyncVarSize) - 8usize];
};
pub type HsaSyncVar = _HsaSyncVar;
pub const _HSA_EVENTTYPE_NODECHANGE_FLAGS_HSA_EVENTTYPE_NODECHANGE_ADD:
    _HSA_EVENTTYPE_NODECHANGE_FLAGS = 0;
pub const _HSA_EVENTTYPE_NODECHANGE_FLAGS_HSA_EVENTTYPE_NODECHANGE_REMOVE:
    _HSA_EVENTTYPE_NODECHANGE_FLAGS = 1;
pub const _HSA_EVENTTYPE_NODECHANGE_FLAGS_HSA_EVENTTYPE_NODECHANGE_SIZE:
    _HSA_EVENTTYPE_NODECHANGE_FLAGS = 4294967295;
pub type _HSA_EVENTTYPE_NODECHANGE_FLAGS = ::std::os::raw::c_uint;
pub use self::_HSA_EVENTTYPE_NODECHANGE_FLAGS as HSA_EVENTTYPE_NODECHANGE_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaNodeChange {
    pub Flags: HSA_EVENTTYPE_NODECHANGE_FLAGS,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaNodeChange"][::std::mem::size_of::<_HsaNodeChange>() - 4usize];
    ["Alignment of _HsaNodeChange"][::std::mem::align_of::<_HsaNodeChange>() - 4usize];
    ["Offset of field: _HsaNodeChange::Flags"]
        [::std::mem::offset_of!(_HsaNodeChange, Flags) - 0usize];
};
pub type HsaNodeChange = _HsaNodeChange;
pub const _HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS_HSA_EVENTTYPE_DEVICESTATUSCHANGE_START:
    _HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS = 0;
pub const _HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS_HSA_EVENTTYPE_DEVICESTATUSCHANGE_STOP:
    _HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS = 1;
pub const _HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS_HSA_EVENTTYPE_DEVICESTATUSCHANGE_SIZE:
    _HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS = 4294967295;
pub type _HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS = ::std::os::raw::c_uint;
pub use self::_HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS as HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaDeviceStateChange {
    pub NodeId: HSAuint32,
    pub Device: HSA_DEVICE,
    pub Flags: HSA_EVENTTYPE_DEVICESTATECHANGE_FLAGS,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaDeviceStateChange"][::std::mem::size_of::<_HsaDeviceStateChange>() - 12usize];
    ["Alignment of _HsaDeviceStateChange"]
        [::std::mem::align_of::<_HsaDeviceStateChange>() - 4usize];
    ["Offset of field: _HsaDeviceStateChange::NodeId"]
        [::std::mem::offset_of!(_HsaDeviceStateChange, NodeId) - 0usize];
    ["Offset of field: _HsaDeviceStateChange::Device"]
        [::std::mem::offset_of!(_HsaDeviceStateChange, Device) - 4usize];
    ["Offset of field: _HsaDeviceStateChange::Flags"]
        [::std::mem::offset_of!(_HsaDeviceStateChange, Flags) - 8usize];
};
pub type HsaDeviceStateChange = _HsaDeviceStateChange;
pub const _HSA_EVENTID_MEMORYFLAGS_HSA_EVENTID_MEMORY_RECOVERABLE: _HSA_EVENTID_MEMORYFLAGS = 0;
pub const _HSA_EVENTID_MEMORYFLAGS_HSA_EVENTID_MEMORY_FATAL_PROCESS: _HSA_EVENTID_MEMORYFLAGS = 1;
pub const _HSA_EVENTID_MEMORYFLAGS_HSA_EVENTID_MEMORY_FATAL_VM: _HSA_EVENTID_MEMORYFLAGS = 2;
pub type _HSA_EVENTID_MEMORYFLAGS = ::std::os::raw::c_uint;
pub use self::_HSA_EVENTID_MEMORYFLAGS as HSA_EVENTID_MEMORYFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaAccessAttributeFailure {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaAccessAttributeFailure"]
        [::std::mem::size_of::<_HsaAccessAttributeFailure>() - 4usize];
    ["Alignment of _HsaAccessAttributeFailure"]
        [::std::mem::align_of::<_HsaAccessAttributeFailure>() - 4usize];
};
impl _HsaAccessAttributeFailure {
    #[inline]
    pub fn NotPresent(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NotPresent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NotPresent_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NotPresent_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadOnly_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReadOnly_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn NoExecute(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoExecute(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn NoExecute_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_NoExecute_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn GpuAccess(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GpuAccess(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn GpuAccess_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_GpuAccess_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ECC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ECC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ECC_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ECC_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Imprecise(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Imprecise(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Imprecise_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Imprecise_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ErrorType(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorType(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ErrorType_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ErrorType_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NotPresent: ::std::os::raw::c_uint,
        ReadOnly: ::std::os::raw::c_uint,
        NoExecute: ::std::os::raw::c_uint,
        GpuAccess: ::std::os::raw::c_uint,
        ECC: ::std::os::raw::c_uint,
        Imprecise: ::std::os::raw::c_uint,
        ErrorType: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NotPresent: u32 = unsafe { ::std::mem::transmute(NotPresent) };
            NotPresent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NoExecute: u32 = unsafe { ::std::mem::transmute(NoExecute) };
            NoExecute as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GpuAccess: u32 = unsafe { ::std::mem::transmute(GpuAccess) };
            GpuAccess as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ECC: u32 = unsafe { ::std::mem::transmute(ECC) };
            ECC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Imprecise: u32 = unsafe { ::std::mem::transmute(Imprecise) };
            Imprecise as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let ErrorType: u32 = unsafe { ::std::mem::transmute(ErrorType) };
            ErrorType as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type HsaAccessAttributeFailure = _HsaAccessAttributeFailure;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaMemoryAccessFault {
    pub NodeId: HSAuint32,
    pub VirtualAddress: HSAuint64,
    pub Failure: HsaAccessAttributeFailure,
    pub Flags: HSA_EVENTID_MEMORYFLAGS,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemoryAccessFault"][::std::mem::size_of::<_HsaMemoryAccessFault>() - 20usize];
    ["Alignment of _HsaMemoryAccessFault"]
        [::std::mem::align_of::<_HsaMemoryAccessFault>() - 4usize];
    ["Offset of field: _HsaMemoryAccessFault::NodeId"]
        [::std::mem::offset_of!(_HsaMemoryAccessFault, NodeId) - 0usize];
    ["Offset of field: _HsaMemoryAccessFault::VirtualAddress"]
        [::std::mem::offset_of!(_HsaMemoryAccessFault, VirtualAddress) - 4usize];
    ["Offset of field: _HsaMemoryAccessFault::Failure"]
        [::std::mem::offset_of!(_HsaMemoryAccessFault, Failure) - 12usize];
    ["Offset of field: _HsaMemoryAccessFault::Flags"]
        [::std::mem::offset_of!(_HsaMemoryAccessFault, Flags) - 16usize];
};
pub type HsaMemoryAccessFault = _HsaMemoryAccessFault;
pub const _HSA_EVENTID_HW_EXCEPTION_CAUSE_HSA_EVENTID_HW_EXCEPTION_GPU_HANG:
    _HSA_EVENTID_HW_EXCEPTION_CAUSE = 0;
pub const _HSA_EVENTID_HW_EXCEPTION_CAUSE_HSA_EVENTID_HW_EXCEPTION_ECC:
    _HSA_EVENTID_HW_EXCEPTION_CAUSE = 1;
pub type _HSA_EVENTID_HW_EXCEPTION_CAUSE = ::std::os::raw::c_uint;
pub use self::_HSA_EVENTID_HW_EXCEPTION_CAUSE as HSA_EVENTID_HW_EXCEPTION_CAUSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaHwException {
    pub NodeId: HSAuint32,
    pub ResetType: HSAuint32,
    pub MemoryLost: HSAuint32,
    pub ResetCause: HSA_EVENTID_HW_EXCEPTION_CAUSE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaHwException"][::std::mem::size_of::<_HsaHwException>() - 16usize];
    ["Alignment of _HsaHwException"][::std::mem::align_of::<_HsaHwException>() - 4usize];
    ["Offset of field: _HsaHwException::NodeId"]
        [::std::mem::offset_of!(_HsaHwException, NodeId) - 0usize];
    ["Offset of field: _HsaHwException::ResetType"]
        [::std::mem::offset_of!(_HsaHwException, ResetType) - 4usize];
    ["Offset of field: _HsaHwException::MemoryLost"]
        [::std::mem::offset_of!(_HsaHwException, MemoryLost) - 8usize];
    ["Offset of field: _HsaHwException::ResetCause"]
        [::std::mem::offset_of!(_HsaHwException, ResetCause) - 12usize];
};
pub type HsaHwException = _HsaHwException;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _HsaEventData {
    pub EventType: HSA_EVENTTYPE,
    pub EventData: _HsaEventData__bindgen_ty_1,
    pub HWData1: HSAuint64,
    pub HWData2: HSAuint64,
    pub HWData3: HSAuint32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HsaEventData__bindgen_ty_1 {
    pub SyncVar: HsaSyncVar,
    pub NodeChangeState: HsaNodeChange,
    pub DeviceState: HsaDeviceStateChange,
    pub MemoryAccessFault: HsaMemoryAccessFault,
    pub HwException: HsaHwException,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaEventData__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaEventData__bindgen_ty_1>() - 20usize];
    ["Alignment of _HsaEventData__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaEventData__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaEventData__bindgen_ty_1::SyncVar"]
        [::std::mem::offset_of!(_HsaEventData__bindgen_ty_1, SyncVar) - 0usize];
    ["Offset of field: _HsaEventData__bindgen_ty_1::NodeChangeState"]
        [::std::mem::offset_of!(_HsaEventData__bindgen_ty_1, NodeChangeState) - 0usize];
    ["Offset of field: _HsaEventData__bindgen_ty_1::DeviceState"]
        [::std::mem::offset_of!(_HsaEventData__bindgen_ty_1, DeviceState) - 0usize];
    ["Offset of field: _HsaEventData__bindgen_ty_1::MemoryAccessFault"]
        [::std::mem::offset_of!(_HsaEventData__bindgen_ty_1, MemoryAccessFault) - 0usize];
    ["Offset of field: _HsaEventData__bindgen_ty_1::HwException"]
        [::std::mem::offset_of!(_HsaEventData__bindgen_ty_1, HwException) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaEventData"][::std::mem::size_of::<_HsaEventData>() - 44usize];
    ["Alignment of _HsaEventData"][::std::mem::align_of::<_HsaEventData>() - 4usize];
    ["Offset of field: _HsaEventData::EventType"]
        [::std::mem::offset_of!(_HsaEventData, EventType) - 0usize];
    ["Offset of field: _HsaEventData::EventData"]
        [::std::mem::offset_of!(_HsaEventData, EventData) - 4usize];
    ["Offset of field: _HsaEventData::HWData1"]
        [::std::mem::offset_of!(_HsaEventData, HWData1) - 24usize];
    ["Offset of field: _HsaEventData::HWData2"]
        [::std::mem::offset_of!(_HsaEventData, HWData2) - 32usize];
    ["Offset of field: _HsaEventData::HWData3"]
        [::std::mem::offset_of!(_HsaEventData, HWData3) - 40usize];
};
pub type HsaEventData = _HsaEventData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaEventDescriptor {
    pub EventType: HSA_EVENTTYPE,
    pub NodeId: HSAuint32,
    pub SyncVar: HsaSyncVar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaEventDescriptor"][::std::mem::size_of::<_HsaEventDescriptor>() - 24usize];
    ["Alignment of _HsaEventDescriptor"][::std::mem::align_of::<_HsaEventDescriptor>() - 4usize];
    ["Offset of field: _HsaEventDescriptor::EventType"]
        [::std::mem::offset_of!(_HsaEventDescriptor, EventType) - 0usize];
    ["Offset of field: _HsaEventDescriptor::NodeId"]
        [::std::mem::offset_of!(_HsaEventDescriptor, NodeId) - 4usize];
    ["Offset of field: _HsaEventDescriptor::SyncVar"]
        [::std::mem::offset_of!(_HsaEventDescriptor, SyncVar) - 8usize];
};
pub type HsaEventDescriptor = _HsaEventDescriptor;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaEvent {
    pub EventId: HSA_EVENTID,
    pub EventData: HsaEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaEvent"][::std::mem::size_of::<_HsaEvent>() - 48usize];
    ["Alignment of _HsaEvent"][::std::mem::align_of::<_HsaEvent>() - 4usize];
    ["Offset of field: _HsaEvent::EventId"][::std::mem::offset_of!(_HsaEvent, EventId) - 0usize];
    ["Offset of field: _HsaEvent::EventData"]
        [::std::mem::offset_of!(_HsaEvent, EventData) - 4usize];
};
pub type HsaEvent = _HsaEvent;
pub const _HsaEventTimeout_HSA_EVENTTIMEOUT_IMMEDIATE: _HsaEventTimeout = 0;
pub const _HsaEventTimeout_HSA_EVENTTIMEOUT_INFINITE: _HsaEventTimeout = 4294967295;
pub type _HsaEventTimeout = ::std::os::raw::c_uint;
pub use self::_HsaEventTimeout as HsaEventTimeOut;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaClockCounters {
    pub GPUClockCounter: HSAuint64,
    pub CPUClockCounter: HSAuint64,
    pub SystemClockCounter: HSAuint64,
    pub SystemClockFrequencyHz: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaClockCounters"][::std::mem::size_of::<_HsaClockCounters>() - 32usize];
    ["Alignment of _HsaClockCounters"][::std::mem::align_of::<_HsaClockCounters>() - 4usize];
    ["Offset of field: _HsaClockCounters::GPUClockCounter"]
        [::std::mem::offset_of!(_HsaClockCounters, GPUClockCounter) - 0usize];
    ["Offset of field: _HsaClockCounters::CPUClockCounter"]
        [::std::mem::offset_of!(_HsaClockCounters, CPUClockCounter) - 8usize];
    ["Offset of field: _HsaClockCounters::SystemClockCounter"]
        [::std::mem::offset_of!(_HsaClockCounters, SystemClockCounter) - 16usize];
    ["Offset of field: _HsaClockCounters::SystemClockFrequencyHz"]
        [::std::mem::offset_of!(_HsaClockCounters, SystemClockFrequencyHz) - 24usize];
};
pub type HsaClockCounters = _HsaClockCounters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HSA_UUID {
    pub Data1: HSAuint32,
    pub Data2: HSAuint16,
    pub Data3: HSAuint16,
    pub Data4: [HSAuint8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HSA_UUID"][::std::mem::size_of::<_HSA_UUID>() - 16usize];
    ["Alignment of _HSA_UUID"][::std::mem::align_of::<_HSA_UUID>() - 4usize];
    ["Offset of field: _HSA_UUID::Data1"][::std::mem::offset_of!(_HSA_UUID, Data1) - 0usize];
    ["Offset of field: _HSA_UUID::Data2"][::std::mem::offset_of!(_HSA_UUID, Data2) - 4usize];
    ["Offset of field: _HSA_UUID::Data3"][::std::mem::offset_of!(_HSA_UUID, Data3) - 6usize];
    ["Offset of field: _HSA_UUID::Data4"][::std::mem::offset_of!(_HSA_UUID, Data4) - 8usize];
};
pub type HSA_UUID = _HSA_UUID;
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_CB: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_CPF: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_CPG: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_DB: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_GDS: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_GRBM: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_GRBMSE: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_IA: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_MC: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_PASC: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_PASU: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_SPI: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_SRBM: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_SQ: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_SX: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_TA: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_TCA: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_TCC: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_TCP: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_TCS: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_TD: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_VGT: HSA_UUID;
}
unsafe extern "C" {
    pub static HSA_PROFILEBLOCK_AMD_WD: HSA_UUID;
}
pub const _HSA_PROFILE_TYPE_HSA_PROFILE_TYPE_PRIVILEGED_IMMEDIATE: _HSA_PROFILE_TYPE = 0;
pub const _HSA_PROFILE_TYPE_HSA_PROFILE_TYPE_PRIVILEGED_STREAMING: _HSA_PROFILE_TYPE = 1;
pub const _HSA_PROFILE_TYPE_HSA_PROFILE_TYPE_NONPRIV_IMMEDIATE: _HSA_PROFILE_TYPE = 2;
pub const _HSA_PROFILE_TYPE_HSA_PROFILE_TYPE_NONPRIV_STREAMING: _HSA_PROFILE_TYPE = 3;
pub const _HSA_PROFILE_TYPE_HSA_PROFILE_TYPE_NUM: _HSA_PROFILE_TYPE = 4;
pub const _HSA_PROFILE_TYPE_HSA_PROFILE_TYPE_SIZE: _HSA_PROFILE_TYPE = 4294967295;
pub type _HSA_PROFILE_TYPE = ::std::os::raw::c_uint;
pub use self::_HSA_PROFILE_TYPE as HSA_PROFILE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaCounterFlags {
    pub __bindgen_anon_1: _HsaCounterFlags__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HsaCounterFlags__bindgen_ty_1 {
    pub ui32: _HsaCounterFlags__bindgen_ty_1__bindgen_ty_1,
    pub Value: HSAuint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HsaCounterFlags__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaCounterFlags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaCounterFlags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of _HsaCounterFlags__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaCounterFlags__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl _HsaCounterFlags__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Global(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Global_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Global_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Resettable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Resettable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Resettable_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Resettable_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ReadOnly(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnly(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ReadOnly_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ReadOnly_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Stream(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Stream(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Stream_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Stream_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn Reserved_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                28u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_Reserved_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                28u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Global: ::std::os::raw::c_uint,
        Resettable: ::std::os::raw::c_uint,
        ReadOnly: ::std::os::raw::c_uint,
        Stream: ::std::os::raw::c_uint,
        Reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Global: u32 = unsafe { ::std::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Resettable: u32 = unsafe { ::std::mem::transmute(Resettable) };
            Resettable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReadOnly: u32 = unsafe { ::std::mem::transmute(ReadOnly) };
            ReadOnly as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Stream: u32 = unsafe { ::std::mem::transmute(Stream) };
            Stream as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaCounterFlags__bindgen_ty_1"]
        [::std::mem::size_of::<_HsaCounterFlags__bindgen_ty_1>() - 4usize];
    ["Alignment of _HsaCounterFlags__bindgen_ty_1"]
        [::std::mem::align_of::<_HsaCounterFlags__bindgen_ty_1>() - 4usize];
    ["Offset of field: _HsaCounterFlags__bindgen_ty_1::ui32"]
        [::std::mem::offset_of!(_HsaCounterFlags__bindgen_ty_1, ui32) - 0usize];
    ["Offset of field: _HsaCounterFlags__bindgen_ty_1::Value"]
        [::std::mem::offset_of!(_HsaCounterFlags__bindgen_ty_1, Value) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaCounterFlags"][::std::mem::size_of::<_HsaCounterFlags>() - 4usize];
    ["Alignment of _HsaCounterFlags"][::std::mem::align_of::<_HsaCounterFlags>() - 4usize];
};
pub type HsaCounterFlags = _HsaCounterFlags;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _HsaCounter {
    pub Type: HSA_PROFILE_TYPE,
    pub CounterId: HSAuint64,
    pub CounterSizeInBits: HSAuint32,
    pub CounterMask: HSAuint64,
    pub Flags: HsaCounterFlags,
    pub BlockIndex: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaCounter"][::std::mem::size_of::<_HsaCounter>() - 32usize];
    ["Alignment of _HsaCounter"][::std::mem::align_of::<_HsaCounter>() - 4usize];
    ["Offset of field: _HsaCounter::Type"][::std::mem::offset_of!(_HsaCounter, Type) - 0usize];
    ["Offset of field: _HsaCounter::CounterId"]
        [::std::mem::offset_of!(_HsaCounter, CounterId) - 4usize];
    ["Offset of field: _HsaCounter::CounterSizeInBits"]
        [::std::mem::offset_of!(_HsaCounter, CounterSizeInBits) - 12usize];
    ["Offset of field: _HsaCounter::CounterMask"]
        [::std::mem::offset_of!(_HsaCounter, CounterMask) - 16usize];
    ["Offset of field: _HsaCounter::Flags"][::std::mem::offset_of!(_HsaCounter, Flags) - 24usize];
    ["Offset of field: _HsaCounter::BlockIndex"]
        [::std::mem::offset_of!(_HsaCounter, BlockIndex) - 28usize];
};
pub type HsaCounter = _HsaCounter;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaCounterBlockProperties {
    pub BlockId: HSA_UUID,
    pub NumCounters: HSAuint32,
    pub NumConcurrent: HSAuint32,
    pub Counters: [HsaCounter; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaCounterBlockProperties"]
        [::std::mem::size_of::<_HsaCounterBlockProperties>() - 56usize];
    ["Alignment of _HsaCounterBlockProperties"]
        [::std::mem::align_of::<_HsaCounterBlockProperties>() - 4usize];
    ["Offset of field: _HsaCounterBlockProperties::BlockId"]
        [::std::mem::offset_of!(_HsaCounterBlockProperties, BlockId) - 0usize];
    ["Offset of field: _HsaCounterBlockProperties::NumCounters"]
        [::std::mem::offset_of!(_HsaCounterBlockProperties, NumCounters) - 16usize];
    ["Offset of field: _HsaCounterBlockProperties::NumConcurrent"]
        [::std::mem::offset_of!(_HsaCounterBlockProperties, NumConcurrent) - 20usize];
    ["Offset of field: _HsaCounterBlockProperties::Counters"]
        [::std::mem::offset_of!(_HsaCounterBlockProperties, Counters) - 24usize];
};
pub type HsaCounterBlockProperties = _HsaCounterBlockProperties;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaCounterProperties {
    pub NumBlocks: HSAuint32,
    pub NumConcurrent: HSAuint32,
    pub Blocks: [HsaCounterBlockProperties; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaCounterProperties"][::std::mem::size_of::<_HsaCounterProperties>() - 64usize];
    ["Alignment of _HsaCounterProperties"]
        [::std::mem::align_of::<_HsaCounterProperties>() - 4usize];
    ["Offset of field: _HsaCounterProperties::NumBlocks"]
        [::std::mem::offset_of!(_HsaCounterProperties, NumBlocks) - 0usize];
    ["Offset of field: _HsaCounterProperties::NumConcurrent"]
        [::std::mem::offset_of!(_HsaCounterProperties, NumConcurrent) - 4usize];
    ["Offset of field: _HsaCounterProperties::Blocks"]
        [::std::mem::offset_of!(_HsaCounterProperties, Blocks) - 8usize];
};
pub type HsaCounterProperties = _HsaCounterProperties;
pub type HSATraceId = HSAuint64;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaPmcTraceRoot {
    pub TraceBufferMinSizeBytes: HSAuint64,
    pub NumberOfPasses: HSAuint32,
    pub TraceId: HSATraceId,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaPmcTraceRoot"][::std::mem::size_of::<_HsaPmcTraceRoot>() - 20usize];
    ["Alignment of _HsaPmcTraceRoot"][::std::mem::align_of::<_HsaPmcTraceRoot>() - 4usize];
    ["Offset of field: _HsaPmcTraceRoot::TraceBufferMinSizeBytes"]
        [::std::mem::offset_of!(_HsaPmcTraceRoot, TraceBufferMinSizeBytes) - 0usize];
    ["Offset of field: _HsaPmcTraceRoot::NumberOfPasses"]
        [::std::mem::offset_of!(_HsaPmcTraceRoot, NumberOfPasses) - 8usize];
    ["Offset of field: _HsaPmcTraceRoot::TraceId"]
        [::std::mem::offset_of!(_HsaPmcTraceRoot, TraceId) - 12usize];
};
pub type HsaPmcTraceRoot = _HsaPmcTraceRoot;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaGpuTileConfig {
    pub TileConfig: *mut HSAuint32,
    pub MacroTileConfig: *mut HSAuint32,
    pub NumTileConfigs: HSAuint32,
    pub NumMacroTileConfigs: HSAuint32,
    pub GbAddrConfig: HSAuint32,
    pub NumBanks: HSAuint32,
    pub NumRanks: HSAuint32,
    pub Reserved: [HSAuint32; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaGpuTileConfig"][::std::mem::size_of::<_HsaGpuTileConfig>() - 64usize];
    ["Alignment of _HsaGpuTileConfig"][::std::mem::align_of::<_HsaGpuTileConfig>() - 4usize];
    ["Offset of field: _HsaGpuTileConfig::TileConfig"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, TileConfig) - 0usize];
    ["Offset of field: _HsaGpuTileConfig::MacroTileConfig"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, MacroTileConfig) - 8usize];
    ["Offset of field: _HsaGpuTileConfig::NumTileConfigs"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, NumTileConfigs) - 16usize];
    ["Offset of field: _HsaGpuTileConfig::NumMacroTileConfigs"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, NumMacroTileConfigs) - 20usize];
    ["Offset of field: _HsaGpuTileConfig::GbAddrConfig"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, GbAddrConfig) - 24usize];
    ["Offset of field: _HsaGpuTileConfig::NumBanks"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, NumBanks) - 28usize];
    ["Offset of field: _HsaGpuTileConfig::NumRanks"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, NumRanks) - 32usize];
    ["Offset of field: _HsaGpuTileConfig::Reserved"]
        [::std::mem::offset_of!(_HsaGpuTileConfig, Reserved) - 36usize];
};
pub type HsaGpuTileConfig = _HsaGpuTileConfig;
pub const _HSA_POINTER_TYPE_HSA_POINTER_UNKNOWN: _HSA_POINTER_TYPE = 0;
pub const _HSA_POINTER_TYPE_HSA_POINTER_ALLOCATED: _HSA_POINTER_TYPE = 1;
pub const _HSA_POINTER_TYPE_HSA_POINTER_REGISTERED_USER: _HSA_POINTER_TYPE = 2;
pub const _HSA_POINTER_TYPE_HSA_POINTER_REGISTERED_GRAPHICS: _HSA_POINTER_TYPE = 3;
pub const _HSA_POINTER_TYPE_HSA_POINTER_REGISTERED_SHARED: _HSA_POINTER_TYPE = 4;
pub const _HSA_POINTER_TYPE_HSA_POINTER_RESERVED_ADDR: _HSA_POINTER_TYPE = 5;
pub type _HSA_POINTER_TYPE = ::std::os::raw::c_uint;
pub use self::_HSA_POINTER_TYPE as HSA_POINTER_TYPE;
// FIXME bindings c repr
// #[repr(C, packed(4))]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HsaPointerInfo {
    pub Type: HSA_POINTER_TYPE,
    pub Node: HSAuint32,
    pub MemFlags: HsaMemFlags,
    pub CPUAddress: *mut ::std::os::raw::c_void,
    pub GPUAddress: HSAuint64,
    pub SizeInBytes: HSAuint64,
    pub NRegisteredNodes: HSAuint32,
    pub NMappedNodes: HSAuint32,
    pub RegisteredNodes: *const HSAuint32,
    pub MappedNodes: *const HSAuint32,
    pub UserData: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    // ["Size of _HsaPointerInfo"][::std::mem::size_of::<_HsaPointerInfo>() - 68usize];
    // ["Alignment of _HsaPointerInfo"][::std::mem::align_of::<_HsaPointerInfo>() - 4usize];
    ["Offset of field: _HsaPointerInfo::Type"]
        [::std::mem::offset_of!(_HsaPointerInfo, Type) - 0usize];
    ["Offset of field: _HsaPointerInfo::Node"]
        [::std::mem::offset_of!(_HsaPointerInfo, Node) - 4usize];
    ["Offset of field: _HsaPointerInfo::MemFlags"]
        [::std::mem::offset_of!(_HsaPointerInfo, MemFlags) - 8usize];
    // ["Offset of field: _HsaPointerInfo::CPUAddress"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, CPUAddress) - 12usize];
    // ["Offset of field: _HsaPointerInfo::GPUAddress"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, GPUAddress) - 20usize];
    // ["Offset of field: _HsaPointerInfo::SizeInBytes"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, SizeInBytes) - 28usize];
    // ["Offset of field: _HsaPointerInfo::NRegisteredNodes"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, NRegisteredNodes) - 36usize];
    // ["Offset of field: _HsaPointerInfo::NMappedNodes"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, NMappedNodes) - 40usize];
    // ["Offset of field: _HsaPointerInfo::RegisteredNodes"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, RegisteredNodes) - 44usize];
    // ["Offset of field: _HsaPointerInfo::MappedNodes"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, MappedNodes) - 52usize];
    // ["Offset of field: _HsaPointerInfo::UserData"]
    //     [::std::mem::offset_of!(_HsaPointerInfo, UserData) - 60usize];
};
pub type HsaPointerInfo = _HsaPointerInfo;
pub type HsaSharedMemoryHandle = [HSAuint32; 8usize];
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaMemoryRange {
    pub MemoryAddress: *mut ::std::os::raw::c_void,
    pub SizeInBytes: HSAuint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaMemoryRange"][::std::mem::size_of::<_HsaMemoryRange>() - 16usize];
    ["Alignment of _HsaMemoryRange"][::std::mem::align_of::<_HsaMemoryRange>() - 4usize];
    ["Offset of field: _HsaMemoryRange::MemoryAddress"]
        [::std::mem::offset_of!(_HsaMemoryRange, MemoryAddress) - 0usize];
    ["Offset of field: _HsaMemoryRange::SizeInBytes"]
        [::std::mem::offset_of!(_HsaMemoryRange, SizeInBytes) - 8usize];
};
pub type HsaMemoryRange = _HsaMemoryRange;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_HOST_ACCESS: _HSA_SVM_FLAGS = 1;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_COHERENT: _HSA_SVM_FLAGS = 2;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_HIVE_LOCAL: _HSA_SVM_FLAGS = 4;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_GPU_RO: _HSA_SVM_FLAGS = 8;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_GPU_EXEC: _HSA_SVM_FLAGS = 16;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_GPU_READ_MOSTLY: _HSA_SVM_FLAGS = 32;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_GPU_ALWAYS_MAPPED: _HSA_SVM_FLAGS = 64;
pub const _HSA_SVM_FLAGS_HSA_SVM_FLAG_EXT_COHERENT: _HSA_SVM_FLAGS = 128;
pub type _HSA_SVM_FLAGS = ::std::os::raw::c_uint;
pub use self::_HSA_SVM_FLAGS as HSA_SVM_FLAGS;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_PREFERRED_LOC: _HSA_SVM_ATTR_TYPE = 0;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_PREFETCH_LOC: _HSA_SVM_ATTR_TYPE = 1;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_ACCESS: _HSA_SVM_ATTR_TYPE = 2;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_ACCESS_IN_PLACE: _HSA_SVM_ATTR_TYPE = 3;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_NO_ACCESS: _HSA_SVM_ATTR_TYPE = 4;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_SET_FLAGS: _HSA_SVM_ATTR_TYPE = 5;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_CLR_FLAGS: _HSA_SVM_ATTR_TYPE = 6;
pub const _HSA_SVM_ATTR_TYPE_HSA_SVM_ATTR_GRANULARITY: _HSA_SVM_ATTR_TYPE = 7;
pub type _HSA_SVM_ATTR_TYPE = ::std::os::raw::c_uint;
pub use self::_HSA_SVM_ATTR_TYPE as HSA_SVM_ATTR_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HSA_SVM_ATTRIBUTE {
    pub type_: HSAuint32,
    pub value: HSAuint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HSA_SVM_ATTRIBUTE"][::std::mem::size_of::<_HSA_SVM_ATTRIBUTE>() - 8usize];
    ["Alignment of _HSA_SVM_ATTRIBUTE"][::std::mem::align_of::<_HSA_SVM_ATTRIBUTE>() - 4usize];
    ["Offset of field: _HSA_SVM_ATTRIBUTE::type_"]
        [::std::mem::offset_of!(_HSA_SVM_ATTRIBUTE, type_) - 0usize];
    ["Offset of field: _HSA_SVM_ATTRIBUTE::value"]
        [::std::mem::offset_of!(_HSA_SVM_ATTRIBUTE, value) - 4usize];
};
pub type HSA_SVM_ATTRIBUTE = _HSA_SVM_ATTRIBUTE;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_NONE: _HSA_SMI_EVENT = 0;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_VMFAULT: _HSA_SMI_EVENT = 1;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_THERMAL_THROTTLE: _HSA_SMI_EVENT = 2;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_GPU_PRE_RESET: _HSA_SMI_EVENT = 3;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_GPU_POST_RESET: _HSA_SMI_EVENT = 4;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_MIGRATE_START: _HSA_SMI_EVENT = 5;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_MIGRATE_END: _HSA_SMI_EVENT = 6;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_PAGE_FAULT_START: _HSA_SMI_EVENT = 7;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_PAGE_FAULT_END: _HSA_SMI_EVENT = 8;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_QUEUE_EVICTION: _HSA_SMI_EVENT = 9;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_QUEUE_RESTORE: _HSA_SMI_EVENT = 10;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_UNMAP_FROM_GPU: _HSA_SMI_EVENT = 11;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_INDEX_MAX: _HSA_SMI_EVENT = 12;
pub const _HSA_SMI_EVENT_HSA_SMI_EVENT_ALL_PROCESS: _HSA_SMI_EVENT = 64;
pub type _HSA_SMI_EVENT = ::std::os::raw::c_uint;
pub use self::_HSA_SMI_EVENT as HSA_EVENT_TYPE;
pub const _HSA_MIGRATE_TRIGGERS_HSA_MIGRATE_TRIGGER_PREFETCH: _HSA_MIGRATE_TRIGGERS = 0;
pub const _HSA_MIGRATE_TRIGGERS_HSA_MIGRATE_TRIGGER_PAGEFAULT_GPU: _HSA_MIGRATE_TRIGGERS = 1;
pub const _HSA_MIGRATE_TRIGGERS_HSA_MIGRATE_TRIGGER_PAGEFAULT_CPU: _HSA_MIGRATE_TRIGGERS = 2;
pub const _HSA_MIGRATE_TRIGGERS_HSA_MIGRATE_TRIGGER_TTM_EVICTION: _HSA_MIGRATE_TRIGGERS = 3;
pub type _HSA_MIGRATE_TRIGGERS = ::std::os::raw::c_uint;
pub use self::_HSA_MIGRATE_TRIGGERS as HSA_MIGRATE_TRIGGERS;
pub const _HSA_QUEUE_EVICTION_TRIGGERS_HSA_QUEUE_EVICTION_TRIGGER_SVM:
    _HSA_QUEUE_EVICTION_TRIGGERS = 0;
pub const _HSA_QUEUE_EVICTION_TRIGGERS_HSA_QUEUE_EVICTION_TRIGGER_USERPTR:
    _HSA_QUEUE_EVICTION_TRIGGERS = 1;
pub const _HSA_QUEUE_EVICTION_TRIGGERS_HSA_QUEUE_EVICTION_TRIGGER_TTM:
    _HSA_QUEUE_EVICTION_TRIGGERS = 2;
pub const _HSA_QUEUE_EVICTION_TRIGGERS_HSA_QUEUE_EVICTION_TRIGGER_SUSPEND:
    _HSA_QUEUE_EVICTION_TRIGGERS = 3;
pub const _HSA_QUEUE_EVICTION_TRIGGERS_HSA_QUEUE_EVICTION_CRIU_CHECKPOINT:
    _HSA_QUEUE_EVICTION_TRIGGERS = 4;
pub const _HSA_QUEUE_EVICTION_TRIGGERS_HSA_QUEUE_EVICTION_CRIU_RESTORE:
    _HSA_QUEUE_EVICTION_TRIGGERS = 5;
pub type _HSA_QUEUE_EVICTION_TRIGGERS = ::std::os::raw::c_uint;
pub use self::_HSA_QUEUE_EVICTION_TRIGGERS as HSA_QUEUE_EVICTION_TRIGGERS;
pub const _HSA_SVM_UNMAP_TRIGGERS_HSA_SVM_UNMAP_TRIGGER_MMU_NOTIFY: _HSA_SVM_UNMAP_TRIGGERS = 0;
pub const _HSA_SVM_UNMAP_TRIGGERS_HSA_SVM_UNMAP_TRIGGER_MMU_NOTIFY_MIGRATE:
    _HSA_SVM_UNMAP_TRIGGERS = 1;
pub const _HSA_SVM_UNMAP_TRIGGERS_HSA_SVM_UNMAP_TRIGGER_UNMAP_FROM_CPU: _HSA_SVM_UNMAP_TRIGGERS = 2;
pub type _HSA_SVM_UNMAP_TRIGGERS = ::std::os::raw::c_uint;
pub use self::_HSA_SVM_UNMAP_TRIGGERS as HSA_SVM_UNMAP_TRIGGERS;
pub type HsaAMDGPUDeviceHandle = *mut ::std::os::raw::c_void;
pub type HsaPcSamplingTraceId = HSAuint32;
pub const _HSA_PC_SAMPLING_METHOD_KIND_HSA_PC_SAMPLING_METHOD_KIND_HOSTTRAP_V1:
    _HSA_PC_SAMPLING_METHOD_KIND = 1;
pub const _HSA_PC_SAMPLING_METHOD_KIND_HSA_PC_SAMPLING_METHOD_KIND_STOCHASTIC_V1:
    _HSA_PC_SAMPLING_METHOD_KIND = 2;
pub type _HSA_PC_SAMPLING_METHOD_KIND = ::std::os::raw::c_uint;
pub use self::_HSA_PC_SAMPLING_METHOD_KIND as HSA_PC_SAMPLING_METHOD_KIND;
pub const _HSA_PC_SAMPLING_UNITS_HSA_PC_SAMPLING_UNIT_INTERVAL_MICROSECONDS:
    _HSA_PC_SAMPLING_UNITS = 0;
pub const _HSA_PC_SAMPLING_UNITS_HSA_PC_SAMPLING_UNIT_INTERVAL_CYCLES: _HSA_PC_SAMPLING_UNITS = 1;
pub const _HSA_PC_SAMPLING_UNITS_HSA_PC_SAMPLING_UNIT_INTERVAL_INSTRUCTIONS:
    _HSA_PC_SAMPLING_UNITS = 2;
pub type _HSA_PC_SAMPLING_UNITS = ::std::os::raw::c_uint;
pub use self::_HSA_PC_SAMPLING_UNITS as HSA_PC_SAMPLING_UNIT_INTERVAL;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HsaPcSamplingInfo {
    pub value: HSAuint64,
    pub value_min: HSAuint64,
    pub value_max: HSAuint64,
    pub flags: HSAuint64,
    pub method: HSA_PC_SAMPLING_METHOD_KIND,
    pub units: HSA_PC_SAMPLING_UNIT_INTERVAL,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _HsaPcSamplingInfo"][::std::mem::size_of::<_HsaPcSamplingInfo>() - 40usize];
    ["Alignment of _HsaPcSamplingInfo"][::std::mem::align_of::<_HsaPcSamplingInfo>() - 4usize];
    ["Offset of field: _HsaPcSamplingInfo::value"]
        [::std::mem::offset_of!(_HsaPcSamplingInfo, value) - 0usize];
    ["Offset of field: _HsaPcSamplingInfo::value_min"]
        [::std::mem::offset_of!(_HsaPcSamplingInfo, value_min) - 8usize];
    ["Offset of field: _HsaPcSamplingInfo::value_max"]
        [::std::mem::offset_of!(_HsaPcSamplingInfo, value_max) - 16usize];
    ["Offset of field: _HsaPcSamplingInfo::flags"]
        [::std::mem::offset_of!(_HsaPcSamplingInfo, flags) - 24usize];
    ["Offset of field: _HsaPcSamplingInfo::method"]
        [::std::mem::offset_of!(_HsaPcSamplingInfo, method) - 32usize];
    ["Offset of field: _HsaPcSamplingInfo::units"]
        [::std::mem::offset_of!(_HsaPcSamplingInfo, units) - 36usize];
};
pub type HsaPcSamplingInfo = _HsaPcSamplingInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union HSA_REGISTER_MEM_FLAGS {
    pub Value: HSAuint32,
    pub ui32: HSA_REGISTER_MEM_FLAGS__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HSA_REGISTER_MEM_FLAGS__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_REGISTER_MEM_FLAGS__bindgen_ty_1"]
        [::std::mem::size_of::<HSA_REGISTER_MEM_FLAGS__bindgen_ty_1>() - 4usize];
    ["Alignment of HSA_REGISTER_MEM_FLAGS__bindgen_ty_1"]
        [::std::mem::align_of::<HSA_REGISTER_MEM_FLAGS__bindgen_ty_1>() - 4usize];
};
impl HSA_REGISTER_MEM_FLAGS__bindgen_ty_1 {
    #[inline]
    pub fn requiresVAddr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_requiresVAddr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requiresVAddr_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_requiresVAddr_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requiresVAddr: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let requiresVAddr: u32 = unsafe { ::std::mem::transmute(requiresVAddr) };
            requiresVAddr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HSA_REGISTER_MEM_FLAGS"][::std::mem::size_of::<HSA_REGISTER_MEM_FLAGS>() - 4usize];
    ["Alignment of HSA_REGISTER_MEM_FLAGS"]
        [::std::mem::align_of::<HSA_REGISTER_MEM_FLAGS>() - 4usize];
    ["Offset of field: HSA_REGISTER_MEM_FLAGS::Value"]
        [::std::mem::offset_of!(HSA_REGISTER_MEM_FLAGS, Value) - 0usize];
    ["Offset of field: HSA_REGISTER_MEM_FLAGS::ui32"]
        [::std::mem::offset_of!(HSA_REGISTER_MEM_FLAGS, ui32) - 0usize];
};
unsafe extern "C" {
    #[doc = "\"Opens\" the HSA kernel driver for user-kernel mode communication.\n\nOn Windows, this function gets a handle to the KFD's AMDKFDIO device object that\nis responsible for user-kernel communication, this handle is used internally by\nthe thunk library to send device I/O control to the HSA kernel driver.\nNo other thunk library function may be called unless the user-kernel communication\nchannel is opened first.\n\nOn Linux this call opens the \"/dev/kfd\" device file to establish a communication\npath to the kernel."]
    pub fn hsaKmtOpenKFD() -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "\"Closes\" the user-kernel communication path.\n\nOn Windows, the handle obtained by the hsaKmtOpenKFD() function is closed;\nno other communication with the kernel driver is possible after the successful\nexecution of the saKmdCloseKFD() function. Depending on the failure reason,\nthe user-kernel communication path may or may not be still active.\n\nOn Linux the function closes the \"dev/kfd\" device file.\nNo further communication to the kernel driver is allowed until hsaKmtOpenKFD()\nfunction is called again."]
    pub fn hsaKmtCloseKFD() -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Returns the user-kernel interface version supported by KFD.\nHigher major numbers usually add new features to KFD and may break user-kernel\ncompatibility; higher minor numbers define additional functionality associated\nwithin a major number.\nThe calling software should validate that it meets the minimum interface version\nas described in the API specification."]
    pub fn hsaKmtGetVersion(VersionInfo: *mut HsaVersionInfo) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "The function takes a \"snapshot\" of the topology information within the KFD\nto avoid any changes during the enumeration process."]
    pub fn hsaKmtAcquireSystemProperties(
        SystemProperties: *mut HsaSystemProperties,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Releases the topology \"snapshot\" taken by hsaKmtAcquireSystemProperties()"]
    pub fn hsaKmtReleaseSystemProperties() -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Retrieves the discoverable sub-properties for a given HSA\nnode. The parameters returned allow the application or runtime to size the\nmanagement structures necessary to store the information."]
    pub fn hsaKmtGetNodeProperties(
        NodeId: HSAuint32,
        NodeProperties: *mut HsaNodeProperties,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Retrieves the memory properties of a specific HSA node.\nthe memory pointer passed as MemoryProperties is sized as\nNumBanks * sizeof(HsaMemoryProperties). NumBanks is retrieved with the\nhsaKmtGetNodeProperties() call.\n\nSome of the data returned is optional. Not all implementations may return all\nparameters in the hsaMemoryProperties."]
    pub fn hsaKmtGetNodeMemoryProperties(
        NodeId: HSAuint32,
        NumBanks: HSAuint32,
        MemoryProperties: *mut HsaMemoryProperties,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Retrieves the cache properties of a specific HSA node and processor ID.\nProcessorID refers to either a CPU core or a SIMD unit as enumerated earlier\nvia the hsaKmtGetNodeProperties() call.\nThe memory pointer passed as CacheProperties is sized as\nNumCaches * sizeof(HsaCacheProperties). NumCaches is retrieved with the\nhsaKmtGetNodeProperties() call.\n\nThe data returned is optional. Not all implementations may return all\nparameters in the CacheProperties."]
    pub fn hsaKmtGetNodeCacheProperties(
        NodeId: HSAuint32,
        ProcessorId: HSAuint32,
        NumCaches: HSAuint32,
        CacheProperties: *mut HsaCacheProperties,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Retrieves the HSA IO affinity properties of a specific HSA node.\nthe memory pointer passed as Properties is sized as\nNumIoLinks * sizeof(HsaIoLinkProperties). NumIoLinks is retrieved with the\nhsaKmtGetNodeProperties() call.\n\nThe data returned is optional. Not all implementations may return all\nparameters in the IoLinkProperties."]
    pub fn hsaKmtGetNodeIoLinkProperties(
        NodeId: HSAuint32,
        NumIoLinks: HSAuint32,
        IoLinkProperties: *mut HsaIoLinkProperties,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Creates an operating system event associated with a HSA event ID"]
    pub fn hsaKmtCreateEvent(
        EventDesc: *mut HsaEventDescriptor,
        ManualReset: bool,
        IsSignaled: bool,
        Event: *mut *mut HsaEvent,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Destroys an operating system event associated with a HSA event ID"]
    pub fn hsaKmtDestroyEvent(Event: *mut HsaEvent) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Sets the specified event object to the signaled state"]
    pub fn hsaKmtSetEvent(Event: *mut HsaEvent) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Sets the specified event object to the non-signaled state"]
    pub fn hsaKmtResetEvent(Event: *mut HsaEvent) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Queries the state of the specified event object"]
    pub fn hsaKmtQueryEventState(Event: *mut HsaEvent) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Checks the current state of the event object. If the object's state is\nnonsignaled, the calling thread enters the wait state.\n\nThe function returns when one of the following occurs:\n- The specified event object is in the signaled state.\n- The time-out interval elapses."]
    pub fn hsaKmtWaitOnEvent(Event: *mut HsaEvent, Milliseconds: HSAuint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Checks the current state of the event object. If the object's state is\nnonsignaled, the calling thread enters the wait state. event_age can\nhelp avoiding race conditions.\n\nThe function returns when one of the following occurs:\n- The specified event object is in the signaled state.\n- The time-out interval elapses.\n- Tracking event age"]
    pub fn hsaKmtWaitOnEvent_Ext(
        Event: *mut HsaEvent,
        Milliseconds: HSAuint32,
        event_age: *mut u64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Checks the current state of multiple event objects.\n\nThe function returns when one of the following occurs:\n- Either any one or all of the specified objects are in the signaled state\n- if \"WaitOnAll\" is \"true\" the function returns when the state of all\nobjects in array is signaled\n- if \"WaitOnAll\" is \"false\" the function returns when the state of any\none of the objects is set to signaled\n- The time-out interval elapses."]
    pub fn hsaKmtWaitOnMultipleEvents(
        Events: *mut *mut HsaEvent,
        NumEvents: HSAuint32,
        WaitOnAll: bool,
        Milliseconds: HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Checks the current state of multiple event objects.\nevent_age can help avoiding race conditions.\n\nThe function returns when one of the following occurs:\n- Either any one or all of the specified objects are in the signaled state\n- if \"WaitOnAll\" is \"true\" the function returns when the state of all\nobjects in array is signaled\n- if \"WaitOnAll\" is \"false\" the function returns when the state of any\none of the objects is set to signaled\n- The time-out interval elapses.\n- Tracking event age"]
    pub fn hsaKmtWaitOnMultipleEvents_Ext(
        Events: *mut *mut HsaEvent,
        NumEvents: HSAuint32,
        WaitOnAll: bool,
        Milliseconds: HSAuint32,
        event_age: *mut u64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "new TEMPORARY function definition - to be used only on \"Triniti + Southern Islands\" platform\nIf used on other platforms the function will return HSAKMT_STATUS_ERROR"]
    pub fn hsaKmtReportQueue(
        QueueId: HSA_QUEUEID,
        QueueReport: *mut HsaQueueReport,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Creates a GPU queue with user-mode access rights"]
    pub fn hsaKmtCreateQueue(
        NodeId: HSAuint32,
        Type: HSA_QUEUE_TYPE,
        QueuePercentage: HSAuint32,
        Priority: HSA_QUEUE_PRIORITY,
        QueueAddress: *mut ::std::os::raw::c_void,
        QueueSizeInBytes: HSAuint64,
        Event: *mut HsaEvent,
        QueueResource: *mut HsaQueueResource,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Creates a GPU queue with user-mode access rights"]
    pub fn hsaKmtCreateQueueExt(
        NodeId: HSAuint32,
        Type: HSA_QUEUE_TYPE,
        QueuePercentage: HSAuint32,
        Priority: HSA_QUEUE_PRIORITY,
        SdmaEngineId: HSAuint32,
        QueueAddress: *mut ::std::os::raw::c_void,
        QueueSizeInBytes: HSAuint64,
        Event: *mut HsaEvent,
        QueueResource: *mut HsaQueueResource,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Updates a queue"]
    pub fn hsaKmtUpdateQueue(
        QueueId: HSA_QUEUEID,
        QueuePercentage: HSAuint32,
        Priority: HSA_QUEUE_PRIORITY,
        QueueAddress: *mut ::std::os::raw::c_void,
        QueueSize: HSAuint64,
        Event: *mut HsaEvent,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Destroys a queue"]
    pub fn hsaKmtDestroyQueue(QueueId: HSA_QUEUEID) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Set cu mask for a queue"]
    pub fn hsaKmtSetQueueCUMask(
        QueueId: HSA_QUEUEID,
        CUMaskCount: HSAuint32,
        QueueCUMask: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtGetQueueInfo(QueueId: HSA_QUEUEID, QueueInfo: *mut HsaQueueInfo) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Allows an HSA process to set/change the default and alternate memory coherency, before starting to dispatch."]
    pub fn hsaKmtSetMemoryPolicy(
        Node: HSAuint32,
        DefaultPolicy: HSAuint32,
        AlternatePolicy: HSAuint32,
        MemoryAddressAlternate: *mut ::std::os::raw::c_void,
        MemorySizeInBytes: HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Allocates a memory buffer that may be accessed by the GPU"]
    pub fn hsaKmtAllocMemory(
        PreferredNode: HSAuint32,
        SizeInBytes: HSAuint64,
        MemFlags: HsaMemFlags,
        MemoryAddress: *mut *mut ::std::os::raw::c_void,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Allocates a memory buffer with specific alignment that may be accessed by the GPU\nIf Alignment is 0, the smallest possible alignment will be used"]
    pub fn hsaKmtAllocMemoryAlign(
        PreferredNode: HSAuint32,
        SizeInBytes: HSAuint64,
        Alignment: HSAuint64,
        MemFlags: HsaMemFlags,
        MemoryAddress: *mut *mut ::std::os::raw::c_void,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Frees a memory buffer"]
    pub fn hsaKmtFreeMemory(
        MemoryAddress: *mut ::std::os::raw::c_void,
        SizeInBytes: HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Inquires memory available for allocation as a memory buffer"]
    pub fn hsaKmtAvailableMemory(Node: HSAuint32, AvailableBytes: *mut HSAuint64) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Registers with KFD a memory buffer that may be accessed by the GPU"]
    pub fn hsaKmtRegisterMemory(
        MemoryAddress: *mut ::std::os::raw::c_void,
        MemorySizeInBytes: HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Registers with KFD a memory buffer that may be accessed by specific GPUs"]
    pub fn hsaKmtRegisterMemoryToNodes(
        MemoryAddress: *mut ::std::os::raw::c_void,
        MemorySizeInBytes: HSAuint64,
        NumberOfNodes: HSAuint64,
        NodeArray: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Registers with KFD a memory buffer with memory attributes"]
    pub fn hsaKmtRegisterMemoryWithFlags(
        MemoryAddress: *mut ::std::os::raw::c_void,
        MemorySizeInBytes: HSAuint64,
        MemFlags: HsaMemFlags,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Registers with KFD a graphics buffer and returns graphics metadata"]
    pub fn hsaKmtRegisterGraphicsHandleToNodes(
        GraphicsResourceHandle: HSAuint64,
        GraphicsResourceInfo: *mut HsaGraphicsResourceInfo,
        NumberOfNodes: HSAuint64,
        NodeArray: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Similar to hsaKmtRegisterGraphicsHandleToNodes but provides registration\noptions via RegisterFlags."]
    pub fn hsaKmtRegisterGraphicsHandleToNodesExt(
        GraphicsResourceHandle: HSAuint64,
        GraphicsResourceInfo: *mut HsaGraphicsResourceInfo,
        NumberOfNodes: HSAuint64,
        NodeArray: *mut HSAuint32,
        RegisterFlags: HSA_REGISTER_MEM_FLAGS,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = " Export a dmabuf handle and offset for a given memory address\n\n Validates that @MemoryAddress belongs to a valid allocation and that the\n @MemorySizeInBytes doesn't exceed the end of that allocation. Returns a\n dmabuf fd of the allocation and the offset of MemoryAddress within that\n allocation. The memory will remain allocated even after the allocation is\n freed by hsaKmtFreeMemory for as long as a dmabuf fd remains open or any\n importer of that fd maintains an active reference to the memory."]
    pub fn hsaKmtExportDMABufHandle(
        MemoryAddress: *mut ::std::os::raw::c_void,
        MemorySizeInBytes: HSAuint64,
        DMABufFd: *mut ::std::os::raw::c_int,
        Offset: *mut HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Export a memory buffer for sharing with other processes\n\nNOTE: for the current revision of the thunk spec, SizeInBytes\nmust match whole allocation."]
    pub fn hsaKmtShareMemory(
        MemoryAddress: *mut ::std::os::raw::c_void,
        SizeInBytes: HSAuint64,
        SharedMemoryHandle: *mut HsaSharedMemoryHandle,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Register shared memory handle"]
    pub fn hsaKmtRegisterSharedHandle(
        SharedMemoryHandle: *const HsaSharedMemoryHandle,
        MemoryAddress: *mut *mut ::std::os::raw::c_void,
        SizeInBytes: *mut HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Register shared memory handle to specific nodes only"]
    pub fn hsaKmtRegisterSharedHandleToNodes(
        SharedMemoryHandle: *const HsaSharedMemoryHandle,
        MemoryAddress: *mut *mut ::std::os::raw::c_void,
        SizeInBytes: *mut HSAuint64,
        NumberOfNodes: HSAuint64,
        NodeArray: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Copy data from the GPU address space of the process identified\nby Pid. Size Copied will return actual amount of data copied.\nIf return is not SUCCESS, partial copies could have happened."]
    pub fn hsaKmtProcessVMRead(
        Pid: HSAuint32,
        LocalMemoryArray: *mut HsaMemoryRange,
        LocalMemoryArrayCount: HSAuint64,
        RemoteMemoryArray: *mut HsaMemoryRange,
        RemoteMemoryArrayCount: HSAuint64,
        SizeCopied: *mut HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Write data to the GPU address space of the process identified\nby Pid. See also hsaKmtProcessVMRead."]
    pub fn hsaKmtProcessVMWrite(
        Pid: HSAuint32,
        LocalMemoryArray: *mut HsaMemoryRange,
        LocalMemoryArrayCount: HSAuint64,
        RemoteMemoryArray: *mut HsaMemoryRange,
        RemoteMemoryArrayCount: HSAuint64,
        SizeCopied: *mut HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Unregisters with KFD a memory buffer"]
    pub fn hsaKmtDeregisterMemory(MemoryAddress: *mut ::std::os::raw::c_void) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Ensures that the memory is resident and can be accessed by GPU"]
    pub fn hsaKmtMapMemoryToGPU(
        MemoryAddress: *mut ::std::os::raw::c_void,
        MemorySizeInBytes: HSAuint64,
        AlternateVAGPU: *mut HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Ensures that the memory is resident and can be accessed by GPUs"]
    pub fn hsaKmtMapMemoryToGPUNodes(
        MemoryAddress: *mut ::std::os::raw::c_void,
        MemorySizeInBytes: HSAuint64,
        AlternateVAGPU: *mut HSAuint64,
        MemMapFlags: HsaMemMapFlags,
        NumberOfNodes: HSAuint64,
        NodeArray: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Releases the residency of the memory"]
    pub fn hsaKmtUnmapMemoryToGPU(MemoryAddress: *mut ::std::os::raw::c_void) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Notifies the kernel driver that a process wants to use GPU debugging facilities"]
    pub fn hsaKmtMapGraphicHandle(
        NodeId: HSAuint32,
        GraphicDeviceHandle: HSAuint64,
        GraphicResourceHandle: HSAuint64,
        GraphicResourceOffset: HSAuint64,
        GraphicResourceSize: HSAuint64,
        FlatMemoryAddress: *mut HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Stub for Unmap Graphic Handle"]
    pub fn hsaKmtUnmapGraphicHandle(
        NodeId: HSAuint32,
        FlatMemoryAddress: HSAuint64,
        SizeInBytes: HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = " Get an AMDGPU device handle for a GPU node"]
    pub fn hsaKmtGetAMDGPUDeviceHandle(
        NodeId: HSAuint32,
        DeviceHandle: *mut HsaAMDGPUDeviceHandle,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Allocate GWS resource for a queue"]
    pub fn hsaKmtAllocQueueGWS(
        QueueId: HSA_QUEUEID,
        nGWS: HSAuint32,
        firstGWS: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Notifies the kernel driver that a process wants to use GPU debugging facilities"]
    pub fn hsaKmtDbgRegister(NodeId: HSAuint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Detaches the debugger process from the HW debug established by hsaKmtDbgRegister() API"]
    pub fn hsaKmtDbgUnregister(NodeId: HSAuint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Controls a wavefront"]
    pub fn hsaKmtDbgWavefrontControl(
        NodeId: HSAuint32,
        Operand: HSA_DBG_WAVEOP,
        Mode: HSA_DBG_WAVEMODE,
        TrapId: HSAuint32,
        DbgWaveMsgRing: *mut HsaDbgWaveMessage,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Sets watch points on memory address ranges to generate exception events when the\nwatched addresses are  accessed"]
    pub fn hsaKmtDbgAddressWatch(
        NodeId: HSAuint32,
        NumWatchPoints: HSAuint32,
        WatchMode: *mut HSA_DBG_WATCH_MODE,
        WatchAddress: *mut *mut ::std::os::raw::c_void,
        WatchMask: *mut HSAuint64,
        WatchEvent: *mut *mut HsaEvent,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtRuntimeEnable(
        rDebug: *mut ::std::os::raw::c_void,
        setupTtmp: bool,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtRuntimeDisable() -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtGetRuntimeCapabilities(caps_mask: *mut HSAuint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Enable debug trap."]
    pub fn hsaKmtDbgEnable(
        runtime_info: *mut *mut ::std::os::raw::c_void,
        data_size: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Disable debug trap."]
    pub fn hsaKmtDbgDisable() -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Get device snapshot."]
    pub fn hsaKmtDbgGetDeviceData(
        data: *mut *mut ::std::os::raw::c_void,
        n_entries: *mut HSAuint32,
        entry_size: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Get queues snapshot."]
    pub fn hsaKmtDbgGetQueueData(
        data: *mut *mut ::std::os::raw::c_void,
        n_entries: *mut HSAuint32,
        entry_size: *mut HSAuint32,
        suspend_queues: bool,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Check whether gpu firmware and kernel support debugging"]
    pub fn hsaKmtCheckRuntimeDebugSupport() -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Debug ops call primarily used for KFD testing"]
    pub fn hsaKmtDebugTrapIoctl(
        arg: *mut __BindgenOpaqueArray<u8, 0usize>,
        Queues: *mut HSA_QUEUEID,
        DebugReturn: *mut HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Gets GPU and CPU clock counters for particular Node"]
    pub fn hsaKmtGetClockCounters(
        NodeId: HSAuint32,
        Counters: *mut HsaClockCounters,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Retrieves information on the available HSA counters"]
    pub fn hsaKmtPmcGetCounterProperties(
        NodeId: HSAuint32,
        CounterProperties: *mut *mut HsaCounterProperties,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Registers a set of (HW) counters to be used for tracing/profiling"]
    pub fn hsaKmtPmcRegisterTrace(
        NodeId: HSAuint32,
        NumberOfCounters: HSAuint32,
        Counters: *mut HsaCounter,
        TraceRoot: *mut HsaPmcTraceRoot,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Unregisters a set of (HW) counters used for tracing/profiling"]
    pub fn hsaKmtPmcUnregisterTrace(NodeId: HSAuint32, TraceId: HSATraceId) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Allows a user mode process to get exclusive access to the defined set of (HW) counters\nused for tracing/profiling"]
    pub fn hsaKmtPmcAcquireTraceAccess(NodeId: HSAuint32, TraceId: HSATraceId) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Allows a user mode process to release exclusive access to the defined set of (HW) counters\nused for tracing/profiling"]
    pub fn hsaKmtPmcReleaseTraceAccess(NodeId: HSAuint32, TraceId: HSATraceId) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Starts tracing operation on a previously established set of performance counters"]
    pub fn hsaKmtPmcStartTrace(
        TraceId: HSATraceId,
        TraceBuffer: *mut ::std::os::raw::c_void,
        TraceBufferSizeBytes: HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Forces an update of all the counters that a previously started trace operation has registered"]
    pub fn hsaKmtPmcQueryTrace(TraceId: HSATraceId) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Stops tracing operation on a previously established set of performance counters"]
    pub fn hsaKmtPmcStopTrace(TraceId: HSATraceId) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Sets trap handler and trap buffer to be used for all queues associated with the specified NodeId within this process context"]
    pub fn hsaKmtSetTrapHandler(
        NodeId: HSAuint32,
        TrapHandlerBaseAddress: *mut ::std::os::raw::c_void,
        TrapHandlerSizeInBytes: HSAuint64,
        TrapBufferBaseAddress: *mut ::std::os::raw::c_void,
        TrapBufferSizeInBytes: HSAuint64,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Gets image tile configuration."]
    pub fn hsaKmtGetTileConfig(NodeId: HSAuint32, config: *mut HsaGpuTileConfig) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Returns information about pointers"]
    pub fn hsaKmtQueryPointerInfo(
        Pointer: *const ::std::os::raw::c_void,
        PointerInfo: *mut HsaPointerInfo,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Associates user data with a memory allocation"]
    pub fn hsaKmtSetMemoryUserData(
        Pointer: *const ::std::os::raw::c_void,
        UserData: *mut ::std::os::raw::c_void,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Acquire request exclusive use of SPM"]
    pub fn hsaKmtSPMAcquire(PreferredNode: HSAuint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Release exclusive use of SPM"]
    pub fn hsaKmtSPMRelease(PreferredNode: HSAuint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Set up the destination user mode buffer for stream performance\ncounter data."]
    pub fn hsaKmtSPMSetDestBuffer(
        PreferredNode: HSAuint32,
        SizeInBytes: HSAuint32,
        timeout: *mut HSAuint32,
        SizeCopied: *mut HSAuint32,
        DestMemoryAddress: *mut ::std::os::raw::c_void,
        isSPMDataLoss: *mut bool,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtSVMSetAttr(
        start_addr: *mut ::std::os::raw::c_void,
        size: HSAuint64,
        nattr: ::std::os::raw::c_uint,
        attrs: *mut HSA_SVM_ATTRIBUTE,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtSVMGetAttr(
        start_addr: *mut ::std::os::raw::c_void,
        size: HSAuint64,
        nattr: ::std::os::raw::c_uint,
        attrs: *mut HSA_SVM_ATTRIBUTE,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtSetXNACKMode(enable: HSAint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    pub fn hsaKmtGetXNACKMode(enable: *mut HSAint32) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Open anonymous file handle to enable events and read SMI events.\n\nTo enable events, write 64bit events mask to fd, event enums as bit index.\nfor example, event mask (HSA_SMI_EVENT_MASK_FROM_INDEX(HSA_SMI_EVENT_INDEX_MAX) - 1) to enable all events\n\nRead event from fd is not blocking, use poll with timeout value to check if event is available.\nEvent is dropped if kernel event fifo is full."]
    pub fn hsaKmtOpenSMI(NodeId: HSAuint32, fd: *mut ::std::os::raw::c_int) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "If this is GPU Mapped memory, remap the first page at this address to be normal system memory\n\nThis is used in ASAN mode to remap the first page of device memory to share host ASAN logic.\nThis function is only supported when libhsakmt is compiled in ASAN mode."]
    pub fn hsaKmtReplaceAsanHeaderPage(addr: *mut ::std::os::raw::c_void) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "If this is GPU Mapped memory, remap the first page back to the original GPU memory\n\nThis is used in ASAN mode to remap the first page back to its original mapping.\nThis function is only supported when libhsakmt is compiled in ASAN mode."]
    pub fn hsaKmtReturnAsanHeaderPage(addr: *mut ::std::os::raw::c_void) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = "Check whether kernel support pc sampling"]
    pub fn hsaKmtPcSamplingSupport() -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = " Query device PC Sampling capabilities\n\n  Arguments:\n   @NodeId        (IN) - GPU node_id\n   @sample_info   (IN) - Pointer to array of HSAPcSamplingInfo\n   @sample_info_sz(IN) - Size of sampling_info in units of HSAPcSamplingInfo\n   @sz_needed     (OUT)- If sampling_info_sz is too small, sample_info_sz needed\n\n  Return:\n   HSAKMT_STATUS_ERROR             - failed\n   HSAKMT_STATUS_SUCCESS           - successfully complete\n   HSAKMT_STATUS_INVALID_PARAMETER - invalid input\n   HSAKMT_STATUS_BUFFER_TOO_SMALL  - sample buffer size is too small. Retry with sample_info_sz\n                                     >= sz_needed\n   HSAKMT_STATUS_NOT_SUPPORTED     - this asic doesn't support pc sampling"]
    pub fn hsaKmtPcSamplingQueryCapabilities(
        NodeId: HSAuint32,
        sample_info: *mut ::std::os::raw::c_void,
        sample_info_sz: HSAuint32,
        sz_needed: *mut HSAuint32,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = " Create PC Sampling Session\n\n  Arguments:\n   @NodeId     (IN)  - GPU node_id\n   @sample_info(IN)  - PC Sampling configuration requested\n   @traceId    (OUT) - Unique PC Sampling trace Id\n\n  Return:\n   HSAKMT_STATUS_ERROR             - failed\n   HSAKMT_STATUS_SUCCESS           - successfully complete\n   HSAKMT_STATUS_INVALID_PARAMETER - invalid input\n   HSAKMT_STATUS_NO_MEMORY         - not enough memory to create new pc sampling session\n   HSAKMT_STATUS_UNAVAILABLE       - a different pc sampling session started on this node"]
    pub fn hsaKmtPcSamplingCreate(
        node_id: HSAuint32,
        sample_info: *mut HsaPcSamplingInfo,
        traceId: *mut HsaPcSamplingTraceId,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = " Destroy PC Sampling Session\n\n  Arguments:\n   @NodeId (IN) - GPU node_id\n   @traceId(IN) - PC Sampling trace Id\n\n  Return:\n   HSAKMT_STATUS_ERROR             - failed\n   HSAKMT_STATUS_SUCCESS           - successfully complete\n   HSAKMT_STATUS_INVALID_PARAMETER - invalid input"]
    pub fn hsaKmtPcSamplingDestroy(
        NodeId: HSAuint32,
        traceId: HsaPcSamplingTraceId,
    ) -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = " Start PC Sampling Session\n\n  Arguments:\n   @NodeId (IN) - GPU node_id\n   @traceId(IN) - PC Sampling trace Id\n\n  Return:\n   HSAKMT_STATUS_ERROR             - failed\n   HSAKMT_STATUS_SUCCESS           - successfully complete\n   HSAKMT_STATUS_INVALID_PARAMETER - invalid input"]
    pub fn hsaKmtPcSamplingStart(NodeId: HSAuint32, traceId: HsaPcSamplingTraceId)
        -> HSAKMT_STATUS;
}
unsafe extern "C" {
    #[doc = " Stop PC Sampling Session\n\n  Arguments:\n   @NodeId (IN) - GPU node_id\n   @traceId(IN) - PC Sampling trace Id\n\n  Return:\n   HSAKMT_STATUS_ERROR                 - failed\n   HSAKMT_STATUS_SUCCESS               - successfully complete\n   HSAKMT_STATUS_INVALID_PARAMETER     - invalid input\n   HSAKMT_STATUS_KERNEL_ALREADY_OPENED - stop already"]
    pub fn hsaKmtPcSamplingStop(NodeId: HSAuint32, traceId: HsaPcSamplingTraceId) -> HSAKMT_STATUS;
}
